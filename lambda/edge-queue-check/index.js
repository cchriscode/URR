/**
 * Lambda@Edge function for CloudFront viewer-request
 * Validates queue entry tokens before allowing access to ticketing APIs
 *
 * Configuration:
 * - Secret is injected at build time via config.json (Lambda@Edge does not support env vars)
 *
 * Protected paths: /api/v1/reservations/**, /api/v1/tickets/** (and legacy /api/ paths)
 * Bypass paths: /api/v1/queue/**, /api/v1/auth/**, /api/v1/events/** (and legacy /api/ paths)
 */

const crypto = require('crypto');

// Lambda@Edge does not support environment variables.
// Secret is injected at build time via config.json generated by Terraform.
let SECRET;
try {
  const config = require('./config.json');
  SECRET = config.secret;
} catch (e) {
  SECRET = process.env.QUEUE_ENTRY_TOKEN_SECRET;
}
if (!SECRET) {
  throw new Error('QUEUE_ENTRY_TOKEN_SECRET is required');
}

// Paths that require valid entry token (v1 and legacy)
const PROTECTED_PATHS = [
  '/api/v1/reservations',
  '/api/v1/tickets',
  '/api/v1/seats',
  '/api/v1/admin',
  '/api/reservations',
  '/api/tickets',
  '/api/seats',
  '/api/admin'
];

// Paths that don't require entry token (v1 and legacy)
const BYPASS_PATHS = [
  '/api/v1/queue',
  '/api/v1/auth',
  '/api/v1/events',
  '/api/v1/stats',
  '/api/queue',
  '/api/auth',
  '/api/events',
  '/api/stats',
  '/health',
  '/actuator'
];

exports.handler = async (event) => {
  const request = event.Records[0].cf.request;
  const uri = request.uri;

  // Check if path is protected
  const isProtected = PROTECTED_PATHS.some(path => uri.startsWith(path));
  const isBypassed = BYPASS_PATHS.some(path => uri.startsWith(path));

  if (!isProtected || isBypassed) {
    // Allow request to pass through
    return request;
  }

  // Extract entry token from cookie or header (fallback)
  const cookies = request.headers.cookie || [];
  let entryToken = null;

  for (const cookieHeader of cookies) {
    const cookieValue = cookieHeader.value;
    const match = cookieValue.match(/tiketi-entry-token=([^;]+)/);
    if (match) {
      entryToken = match[1];
      break;
    }
  }

  // Fallback: check x-queue-entry-token header (API calls from frontend)
  if (!entryToken) {
    const tokenHeaders = request.headers['x-queue-entry-token'];
    if (tokenHeaders && tokenHeaders.length > 0) {
      entryToken = tokenHeaders[0].value;
    }
  }

  if (!entryToken) {
    // No token found, redirect to queue page
    return redirectToQueue(request);
  }

  // Verify JWT and extract claims
  const claims = verifyJWT(entryToken, SECRET);

  if (!claims) {
    // Invalid or expired token, redirect to queue page
    return redirectToQueue(request);
  }

  // Validate eventId in token matches request path
  const eventIdFromPath = extractEventIdFromPath(uri);
  if (eventIdFromPath && claims.sub && claims.sub !== eventIdFromPath) {
    return redirectToQueue(request);
  }

  // Token is valid, allow request
  return request;
};

/**
 * Verify JWT signature and expiration, returns claims object or null
 */
function verifyJWT(token, secret) {
  try {
    const parts = token.split('.');
    if (parts.length !== 3) {
      return null;
    }

    const [headerB64, payloadB64, signatureB64] = parts;

    // Verify signature using timing-safe comparison
    const data = `${headerB64}.${payloadB64}`;
    const expectedSignature = crypto
      .createHmac('sha256', secret)
      .update(data)
      .digest('base64url');

    if (signatureB64.length !== expectedSignature.length ||
        !crypto.timingSafeEqual(Buffer.from(signatureB64), Buffer.from(expectedSignature))) {
      return null;
    }

    // Check expiration
    const payload = JSON.parse(Buffer.from(payloadB64, 'base64url').toString('utf8'));
    const now = Math.floor(Date.now() / 1000);

    if (payload.exp && payload.exp < now) {
      return null;
    }

    return payload;
  } catch (err) {
    console.error('JWT verification error:', err);
    return null;
  }
}

/**
 * Extract eventId from API path (e.g., /api/seats/{eventId}/...)
 */
function extractEventIdFromPath(uri) {
  // Matches UUID pattern in path segments
  const match = uri.match(/\/api\/(?:v1\/)?(?:seats|reservations|tickets)\/([a-f0-9-]{36})/i);
  return match ? match[1] : null;
}

/**
 * Redirect to queue page
 */
function redirectToQueue(request) {
  // Extract eventId from path if possible
  const eventIdMatch = request.uri.match(/\/event\/([a-f0-9-]+)/i);
  const eventId = eventIdMatch ? eventIdMatch[1] : '';

  const redirectUri = eventId ? `/queue/${eventId}` : '/';

  return {
    status: '302',
    statusDescription: 'Found',
    headers: {
      'location': [{
        key: 'Location',
        value: redirectUri
      }],
      'cache-control': [{
        key: 'Cache-Control',
        value: 'no-store, no-cache, must-revalidate'
      }]
    }
  };
}
