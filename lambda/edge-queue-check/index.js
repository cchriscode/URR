/**
 * Lambda@Edge function for CloudFront viewer-request
 *
 * Two-tier VWR (Virtual Waiting Room) token verification:
 *
 * Tier 1 VWR token (urr-vwr-token cookie):
 *   - Issued by VWR API Gateway Lambda after waiting in CDN-level queue
 *   - Contains {tier: 1} claim
 *   - Required when VWR is active for an event (checked via vwr-config.json)
 *   - Without it: redirect to /vwr/{eventId} static waiting page
 *
 * Tier 2 entry token (urr-entry-token cookie / x-queue-entry-token header):
 *   - Issued by queue-service after passing per-event Redis queue
 *   - Required for protected API paths (/api/seats, /api/reservations, etc.)
 *   - Without it: redirect to /queue/{eventId}
 *
 * Configuration:
 * - Secrets injected at build time via config.json (Lambda@Edge does not support env vars)
 *
 * Protected paths: /api/v1/reservations/**, /api/v1/tickets/** (and legacy /api/ paths)
 * Bypass paths: /api/v1/queue/**, /api/v1/auth/**, /api/v1/events/**, /vwr/**, /vwr-api/**
 */

const crypto = require('crypto');
const { getVwrConfig } = require('./vwr-config');

// Lambda@Edge does not support environment variables.
// Secrets are injected at build time via config.json generated by Terraform.
let SECRET, VWR_SECRET;
try {
  const config = require('./config.json');
  SECRET = config.secret;
  VWR_SECRET = config.vwrSecret || config.secret; // fallback to same secret
} catch (e) {
  SECRET = process.env.QUEUE_ENTRY_TOKEN_SECRET;
  VWR_SECRET = process.env.VWR_TOKEN_SECRET || SECRET;
}
if (!SECRET) {
  throw new Error('QUEUE_ENTRY_TOKEN_SECRET is required');
}

// Paths that require valid Tier 2 entry token (v1 and legacy)
const PROTECTED_PATHS = [
  '/api/v1/reservations',
  '/api/v1/tickets',
  '/api/v1/seats',
  '/api/v1/admin',
  '/api/reservations',
  '/api/tickets',
  '/api/seats',
  '/api/admin'
];

// Paths that don't require any token
const BYPASS_PATHS = [
  '/api/v1/queue',
  '/api/v1/auth',
  '/api/v1/events',
  '/api/v1/stats',
  '/api/queue',
  '/api/auth',
  '/api/events',
  '/api/stats',
  '/health',
  '/actuator',
  '/vwr/',
  '/vwr-api/'
];

exports.handler = async (event) => {
  const request = event.Records[0].cf.request;
  const uri = request.uri;

  // Always bypass certain paths
  const isBypassed = BYPASS_PATHS.some(path => uri.startsWith(path));
  if (isBypassed) {
    return request;
  }

  // --- Tier 1 VWR check ---
  // If VWR is active for this event, require Tier 1 VWR token to reach ALB
  const eventIdFromPath = extractEventIdFromPath(uri);
  if (eventIdFromPath) {
    const vwrConfig = await getVwrConfig();
    if (vwrConfig && vwrConfig.activeEvents && vwrConfig.activeEvents.includes(eventIdFromPath)) {
      // VWR is active for this event — check for Tier 1 token
      const vwrToken = extractCookie(request, 'urr-vwr-token');
      if (!vwrToken) {
        return redirectToVwr(eventIdFromPath);
      }
      const vwrClaims = verifyJWT(vwrToken, VWR_SECRET);
      if (!vwrClaims || vwrClaims.tier !== 1) {
        return redirectToVwr(eventIdFromPath);
      }
      // Tier 1 token valid — continue to Tier 2 check if needed
    }
  }

  // --- Tier 2 entry token check ---
  const isProtected = PROTECTED_PATHS.some(path => uri.startsWith(path));
  if (!isProtected) {
    return request;
  }

  // Extract Tier 2 entry token from cookie or header
  let entryToken = extractCookie(request, 'urr-entry-token');
  if (!entryToken) {
    const tokenHeaders = request.headers['x-queue-entry-token'];
    if (tokenHeaders && tokenHeaders.length > 0) {
      entryToken = tokenHeaders[0].value;
    }
  }

  if (!entryToken) {
    return redirectToQueue(request);
  }

  const claims = verifyJWT(entryToken, SECRET);
  if (!claims) {
    return redirectToQueue(request);
  }

  // Validate eventId in token matches request path
  if (eventIdFromPath && claims.sub && claims.sub !== eventIdFromPath) {
    return redirectToQueue(request);
  }

  return request;
};

/**
 * Extract a named cookie value from the request
 */
function extractCookie(request, name) {
  const cookies = request.headers.cookie || [];
  for (const cookieHeader of cookies) {
    const regex = new RegExp('(?:^|;\\s*)' + name + '=([^;]+)');
    const match = cookieHeader.value.match(regex);
    if (match) return decodeURIComponent(match[1]);
  }
  return null;
}

/**
 * Verify JWT signature and expiration, returns claims object or null
 */
function verifyJWT(token, secret) {
  try {
    const parts = token.split('.');
    if (parts.length !== 3) {
      return null;
    }

    const [headerB64, payloadB64, signatureB64] = parts;

    // Verify signature using timing-safe comparison
    const data = `${headerB64}.${payloadB64}`;
    const expectedSignature = crypto
      .createHmac('sha256', secret)
      .update(data)
      .digest('base64url');

    if (signatureB64.length !== expectedSignature.length ||
        !crypto.timingSafeEqual(Buffer.from(signatureB64), Buffer.from(expectedSignature))) {
      return null;
    }

    // Check expiration
    const payload = JSON.parse(Buffer.from(payloadB64, 'base64url').toString('utf8'));
    const now = Math.floor(Date.now() / 1000);

    if (payload.exp && payload.exp < now) {
      return null;
    }

    return payload;
  } catch (err) {
    console.error('JWT verification error:', err);
    return null;
  }
}

/**
 * Extract eventId from request path.
 * Matches both page navigation paths (/events/{uuid}) and
 * API paths (/api/v1/seats/{uuid}, /api/reservations/{uuid}, etc.)
 */
function extractEventIdFromPath(uri) {
  const match = uri.match(
    /\/(?:events|api\/(?:v1\/)?(?:seats|reservations|tickets))\/([a-f0-9-]{36})/i
  );
  return match ? match[1] : null;
}

/**
 * Redirect to Tier 1 VWR static waiting page
 */
function redirectToVwr(eventId) {
  return {
    status: '302',
    statusDescription: 'Found',
    headers: {
      'location': [{ key: 'Location', value: `/vwr/${eventId}` }],
      'cache-control': [{ key: 'Cache-Control', value: 'no-store, no-cache, must-revalidate' }]
    }
  };
}

/**
 * Redirect to Tier 2 queue page
 */
function redirectToQueue(request) {
  const eventIdMatch = request.uri.match(
    /\/(?:events|api\/(?:v1\/)?(?:seats|reservations|tickets))\/([a-f0-9-]{36})/i
  );
  const eventId = eventIdMatch ? eventIdMatch[1] : '';

  return {
    status: '302',
    statusDescription: 'Found',
    headers: {
      'location': [{ key: 'Location', value: eventId ? `/queue/${eventId}` : '/' }],
      'cache-control': [{ key: 'Cache-Control', value: 'no-store, no-cache, must-revalidate' }]
    }
  };
}
