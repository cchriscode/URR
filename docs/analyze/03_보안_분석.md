# URR 플랫폼 보안 분석 보고서

## 1. 인증 체계

### 1-1. JWT 기반 인증

#### Token 생성

JWT 토큰은 `auth-service`의 `JwtService` 클래스에서 생성된다.

- **알고리즘**: HMAC-SHA256 (`Keys.hmacShaKeyFor()` 사용)
  - 파일: `services-spring/auth-service/src/main/java/guru/urr/authservice/security/JwtService.java:115`
- **시크릿**: `JWT_SECRET` 환경변수를 Base64 디코딩하여 사용하며, Base64가 아닐 경우 raw bytes로 폴백한다. 최소 32바이트 검증이 적용되어 있다.
  - 파일: `services-spring/auth-service/src/main/java/guru/urr/authservice/security/JwtService.java:104-116`
- **Access Token Claims**: `sub`(userId), `userId`, `email`, `role`, `type`("access"), `iat`, `exp`
  - 파일: `services-spring/auth-service/src/main/java/guru/urr/authservice/security/JwtService.java:31-46`
- **만료시간**: 기본값 1800초(30분), `JWT_EXPIRATION_SECONDS` 환경변수로 설정 가능
  - 파일: `services-spring/auth-service/src/main/resources/application.yml:57`
- **Refresh Token Claims**: `sub`(userId), `userId`, `type`("refresh"), `familyId`, `jti`(UUID), `iat`, `exp`
  - 파일: `services-spring/auth-service/src/main/java/guru/urr/authservice/security/JwtService.java:48-67`
- **Refresh Token 만료시간**: 기본값 604800초(7일), `JWT_REFRESH_EXPIRATION_SECONDS` 환경변수로 설정 가능
  - 파일: `services-spring/auth-service/src/main/resources/application.yml:58`
- **비밀번호 인코딩**: BCrypt, cost factor 12
  - 파일: `services-spring/auth-service/src/main/java/guru/urr/authservice/config/AppConfig.java:12-14`

#### Gateway를 통한 Token 검증 흐름

인증 흐름은 3단계 필터 체인으로 구성된다 (Order 기준: CookieAuthFilter -> JwtAuthFilter -> VwrEntryTokenFilter).

**1단계: CookieAuthFilter (Order -2)**
- 쿠키에서 `access_token`을 추출하여 `Authorization: Bearer {token}` 헤더로 변환한다.
- 이미 `Authorization` 헤더가 있으면 스킵한다.
- 파일: `services-spring/gateway-service/src/main/java/guru/urr/gatewayservice/filter/CookieAuthFilter.java:18-42`

**2단계: JwtAuthFilter (Order -1)**
- 외부에서 주입된 `X-User-Id`, `X-User-Email`, `X-User-Role` 헤더를 먼저 **모두 제거**하여 스푸핑을 방지한다.
- JWT를 파싱하여 `userId`, `email`, `role` 클레임을 추출한다.
- 검증 성공 시 `X-User-Id`, `X-User-Email`, `X-User-Role` 헤더를 요청에 주입하여 다운스트림 서비스에 전달한다.
- 검증 실패 시 X-User-* 헤더 없이 요청을 전달한다 (에러를 반환하지 않음, 요청은 허용 여부를 다운스트림이 판단).
- 파일: `services-spring/gateway-service/src/main/java/guru/urr/gatewayservice/filter/JwtAuthFilter.java:33-86`
- 헤더 스트리핑: `services-spring/gateway-service/src/main/java/guru/urr/gatewayservice/filter/JwtAuthFilter.java:104-137`

**3단계: 다운스트림 서비스의 JwtTokenParser**
- 각 백엔드 서비스는 Gateway가 주입한 `X-User-Id` 헤더를 읽어 인증 여부를 판단한다.
- JWT 시크릿이 필요 없으며, Gateway에서 이미 검증된 결과를 신뢰한다.
- 파일: `services-spring/urr-common/src/main/java/guru/urr/common/security/JwtTokenParser.java` (6개 서비스 공유)

#### Refresh Token 메커니즘

Refresh Token은 **토큰 로테이션(Token Rotation)** 과 **패밀리 기반 탈취 탐지(Family-based Reuse Detection)** 를 구현하고 있다.

- **토큰 저장**: DB에 SHA-256 해시, familyId, 만료시간, 폐기시간을 저장한다.
  - 파일: `services-spring/auth-service/src/main/java/guru/urr/authservice/service/AuthService.java:289-297`
  - 엔티티: `services-spring/auth-service/src/main/java/guru/urr/authservice/domain/RefreshTokenEntity.java:14-54`
- **갱신 과정**:
  1. Refresh Token의 JWT 서명과 `type: "refresh"` 클레임을 검증한다 (`JwtService.java:95-102`).
  2. DB에서 토큰 해시로 저장된 토큰을 조회한다 (`AuthService.java:128-129`).
  3. 이미 폐기된 토큰이면 **토큰 재사용 탈취**로 판단하여 해당 familyId의 모든 토큰을 폐기한다 (`AuthService.java:131-137`).
  4. 사용된 토큰을 폐기 처리하고(단일 사용), 같은 familyId로 새 토큰을 발급한다 (`AuthService.java:138-152`).
- **로그아웃**: 해당 사용자의 모든 Refresh Token을 폐기한다.
  - 파일: `services-spring/auth-service/src/main/java/guru/urr/authservice/service/AuthService.java:282-287`

#### Cookie 설정

쿠키 설정은 `CookieHelper` 클래스에서 관리한다.
- 파일: `services-spring/auth-service/src/main/java/guru/urr/authservice/util/CookieHelper.java:9-65`

| 속성 | Access Token Cookie | Refresh Token Cookie |
|------|-------------------|--------------------|
| 이름 | `access_token` | `refresh_token` |
| HttpOnly | `true` (line 30) | `true` (line 40) |
| Secure | `${COOKIE_SECURE:true}` (line 19) | `${COOKIE_SECURE:true}` (line 19) |
| SameSite | `Lax` (line 34) | `Lax` (line 44) |
| Path | `/` (line 32) | `/api/auth` (line 42) |
| MaxAge | JWT 만료시간과 동일 (line 33) | Refresh Token 만료시간과 동일 (line 43) |
| Domain | 미설정 (브라우저 기본값 적용) | 미설정 |

**보안 분석**:
- `HttpOnly: true` -- JavaScript를 통한 쿠키 접근 차단 (XSS 방어).
- `Secure: true` -- HTTPS에서만 전송 (기본 활성화).
- `SameSite: Lax` -- CSRF 보호. 단, cross-site POST 요청은 쿠키를 전송하지 않는다.
- Refresh Token의 `Path: /api/auth` -- 갱신 엔드포인트에서만 전송되어 불필요한 노출을 최소화한다.

### 1-2. OAuth 2.0 (Google)

#### OAuth 흐름 구현

프론트엔드에서 Google Identity Services SDK를 통해 `credential` (ID Token)을 획득한 후, 백엔드 `/api/auth/google` 엔드포인트로 전송하는 **One Tap / Sign-In with Google** 방식이다.

- **ID Token 검증**: `GoogleIdTokenVerifier`를 사용하여 Google의 공개키로 서명을 검증한다.
  - Audience 검증: `GOOGLE_CLIENT_ID` 환경변수와 일치하는지 확인한다.
  - 파일: `services-spring/auth-service/src/main/java/guru/urr/authservice/service/AuthService.java:55-62`
  - 검증 로직: `services-spring/auth-service/src/main/java/guru/urr/authservice/service/AuthService.java:197-225`

#### Callback 처리

1. Google ID Token에서 `subject`(googleId), `email`, `name`, `picture`를 추출한다 (`AuthService.java:217-221`).
2. 이메일로 기존 사용자를 조회한다 (`AuthService.java:227`).
3. 신규 사용자: 이메일 기반으로 계정을 생성하고, `googleId`를 설정하며, `passwordHash`를 null로 둔다 (`AuthService.java:228-234`).
4. JWT Access Token과 Refresh Token을 발급하고, 쿠키에 설정한다 (`AuthService.java:240-243`, `AuthController.java:94-99`).

#### 계정 연동

- 동일 이메일로 이미 가입된 계정이 있지만 `googleId`가 없는 경우, Google 로그인 시 자동으로 `googleId`를 연결한다.
  - 파일: `services-spring/auth-service/src/main/java/guru/urr/authservice/service/AuthService.java:235-238`
- Google 전용 계정(`passwordHash == null`)은 이메일/비밀번호 로그인 시 `"Invalid email or password"` 메시지를 반환한다.
  - 파일: `services-spring/auth-service/src/main/java/guru/urr/authservice/service/AuthService.java:91-93`

### 1-3. 내부 서비스 인증

#### Internal API Token 패턴

서비스 간 내부 통신은 공유 시크릿(`INTERNAL_API_TOKEN` 또는 `internal.api-token`)을 사용한다.

- **인증 방식**: `x-internal-token` 헤더 또는 `Authorization: Bearer {token}` 헤더에 토큰을 전달한다.
- **비교 방식**: `MessageDigest.isEqual()`을 사용한 **타이밍 세이프 비교**를 모든 서비스에서 일관되게 적용한다.
- **구현 위치**:
  - auth-service: `services-spring/auth-service/src/main/java/guru/urr/authservice/security/InternalApiAuthFilter.java:37-39` (필터 방식)
  - urr-common (6개 서비스 공용): `services-spring/urr-common/src/main/java/guru/urr/common/security/InternalTokenValidator.java` — catalog, community, payment, queue, stats, ticket 서비스 공용. `InternalTokenValidatorAutoConfiguration`(`@ConditionalOnProperty(name = "INTERNAL_API_TOKEN")`)으로 자동 등록
  - auth-service (자체 버전): `services-spring/auth-service/src/main/java/guru/urr/authservice/security/InternalTokenValidator.java` — boolean 리턴, X-Internal-Token 이중 검증

#### Internal 엔드포인트 목록

| 서비스 | 엔드포인트 | 용도 |
|--------|-----------|------|
| auth-service | `GET /internal/users/{id}` | 사용자 정보 조회 |
| auth-service | `POST /internal/users/batch` | 다수 사용자 일괄 조회 |
| ticket-service | `POST /internal/reschedule-event-status` | 이벤트 상태 갱신 트리거 |
| catalog-service | `GET /internal/events/{eventId}/queue-info` | 이벤트 대기열 정보 조회 |

- 파일: `services-spring/auth-service/src/main/java/guru/urr/authservice/controller/InternalUserController.java:22-62`
- 파일: `services-spring/ticket-service/src/main/java/guru/urr/ticketservice/internal/controller/InternalController.java:13-29`
- 파일: `services-spring/catalog-service/src/main/java/guru/urr/catalogservice/internal/controller/InternalEventController.java:11-29`

#### Gateway의 Auth 헤더 전달

Gateway는 `/internal/**` 경로를 외부에 노출하지 않는다 (라우팅 규칙에 포함되어 있지 않음).
- 파일: `services-spring/gateway-service/src/main/resources/application.yml:10-75` -- 모든 라우트는 `/api/**` 패턴만 사용한다.
- 내부 서비스 간 통신은 K8s 내부 DNS(`service-name.namespace.svc.cluster.local`)를 통해 직접 이루어진다.

---

## 2. 인가 (Authorization)

### Role-Based Access Control

시스템은 `user`와 `admin` 두 가지 역할을 지원한다.
- 파일: `services-spring/auth-service/src/main/java/guru/urr/authservice/domain/UserRole.java:3-6`

역할 검증은 urr-common의 `JwtTokenParser.requireAdmin()` 메서드에서 수행된다.
- 파일: `services-spring/urr-common/src/main/java/guru/urr/common/security/JwtTokenParser.java`
- `AuthUser.isAdmin()`: `"admin".equalsIgnoreCase(role)` 비교
  - 파일: `services-spring/urr-common/src/main/java/guru/urr/common/security/AuthUser.java`

### 공개 / 보호 엔드포인트

**공개 엔드포인트** (auth-service SecurityConfig에서 `permitAll()` 설정):
- `/health`, `/actuator/health/**`, `/actuator/info`, `/actuator/prometheus`
- `/api/auth/register`, `/api/auth/login`, `/api/auth/verify-token`, `/api/auth/google`, `/api/auth/refresh`, `/api/auth/logout`
- `/internal/**`
- 파일: `services-spring/auth-service/src/main/java/guru/urr/authservice/config/SecurityConfig.java:36-39`

**보호 엔드포인트** (`requireUser()` 필요):
- `/api/queue/**` (check, status, heartbeat, leave)
- `/api/reservations/**`, `/api/seats/**`, `/api/tickets/**`
- `/api/community/**` (글 작성, 수정, 삭제)
- `/api/memberships/**`, `/api/transfers/**`

**관리자 전용 엔드포인트** (`requireAdmin()` 필요):
- `/api/admin/**` (dashboard, events CRUD, seats, tickets, reservations)
  - 파일: `services-spring/catalog-service/src/main/java/guru/urr/catalogservice/domain/admin/controller/AdminController.java:40-155`
- `/api/queue/admin/**` (queue admin, clear, threshold)
  - 파일: `services-spring/queue-service/src/main/java/guru/urr/queueservice/controller/QueueController.java:66-94`

### 감사 로그 (Admin Audit)

관리자 행위에 대해 AOP 기반 감사 로그가 기록된다.
- `@AuditLog` 어노테이션이 적용된 모든 관리자 엔드포인트에서 `admin_audit_logs` 테이블에 행위를 기록한다.
- 기록 항목: `admin_user_id`, `action`, `resource_type`, `resource_id`, `response_status`
- 파일: `services-spring/catalog-service/src/main/java/guru/urr/catalogservice/shared/audit/AdminAuditAspect.java:17-88`
- 어노테이션 사용 예: `@AuditLog(action = "CREATE_EVENT", resourceType = "event")` (`AdminController.java:52`)

---

## 3. 네트워크 보안

### 3-1. K8s Network Policies

파일: `k8s/spring/base/network-policies.yaml`

#### Default Deny 규칙

모든 Pod에 대한 Ingress/Egress 트래픽을 기본 거부한다.
```yaml
# line 1-9
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: default-deny-all
spec:
  podSelector: {}
  policyTypes:
    - Ingress
    - Egress
```

#### 서비스 간 허용 트래픽 (Ingress)

| 대상 서비스 | 허용 소스 | 포트 | 정책 이름 (line) |
|------------|----------|------|---------------|
| gateway-service | **모든 소스** | 3001 | `allow-gateway-ingress` (14-24) |
| frontend | **모든 소스** | 3000 | `allow-frontend-ingress` (26-37) |
| auth-service | gateway-service, catalog-service | 3005 | `allow-auth-service-ingress` (40-59) |
| ticket-service | gateway-service, payment-service, catalog-service | 3002 | `allow-ticket-service-ingress` (61-83) |
| catalog-service | gateway-service, queue-service | 3009 | `allow-catalog-service-ingress` (85-104) |
| payment-service | gateway-service | 3003 | `allow-payment-service-ingress` (106-122) |
| stats-service | gateway-service | 3004 | `allow-stats-service-ingress` (124-140) |
| queue-service | gateway-service | 3007 | `allow-queue-service-ingress` (142-158) |
| community-service | gateway-service | 3008 | `allow-community-service-ingress` (160-176) |

#### Egress 규칙

각 서비스별로 최소 권한 원칙에 따라 개별 Egress 정책이 정의되어 있다.

| 서비스 | 허용 대상 | 정책 (line) |
|--------|----------|-----------|
| auth-service | DNS만 | `auth-service-egress` (179-197) |
| ticket-service | payment-service, data 계층, DNS | `ticket-service-egress` (199-223) |
| payment-service | ticket-service, data 계층, DNS | `payment-service-egress` (225-250) |
| queue-service | catalog-service, data 계층, DNS | `queue-service-egress` (252-277) |
| stats-service | data 계층, DNS | `stats-service-egress` (279-300) |
| catalog-service | auth-service, data 계층, DNS | `catalog-service-egress` (302-327) |
| community-service | data 계층, DNS | `community-service-egress` (329-350) |
| gateway-service | backend 계층, kube-dns | `allow-gateway-to-services` (352-375) |

### 3-2. AWS Security Groups

모듈별 보안 그룹 규칙이 최소 권한 원칙에 따라 구성되어 있다.

**ALB Security Group**:
- Ingress: CloudFront managed prefix list를 통한 HTTPS(443)만 허용 -- 직접 ALB 접근 차단
  - 파일: `terraform/modules/alb/main.tf:21-30`
- `drop_invalid_header_fields = true` 설정으로 비정상 헤더 차단
  - 파일: `terraform/modules/alb/main.tf:105`

**RDS Security Group**:
- Ingress: App 계층(EKS 노드) 또는 RDS Proxy에서만 5432 포트 허용
  - 파일: `terraform/modules/rds/main.tf:5-30`
- `publicly_accessible = false`
  - 파일: `terraform/modules/rds/main.tf:75`

**ElastiCache Security Group**:
- Ingress: EKS 노드와 Lambda Worker에서만 6379 포트 허용
  - 파일: `terraform/modules/elasticache/main.tf:5-40`

**MSK Security Group**:
- Ingress: EKS 노드에서 9094(TLS) 또는 9098(IAM Auth) 포트만 허용
- `public_access: DISABLED`
  - 파일: `terraform/modules/msk/main.tf:5-87`, `terraform/modules/msk/main.tf:154-158`

**EKS Cluster Security Group**:
- Control Plane: 제한된 CIDR에서만 443 포트 접근 허용 (`cluster_endpoint_public_access_cidrs`)
  - 파일: `terraform/modules/eks/main.tf:84-92`

### 3-3. VPC 아키텍처

파일: `terraform/modules/vpc/main.tf`

#### 서브넷 계층 구조

| 서브넷 | 용도 | CIDR 오프셋 | 인터넷 접근 |
|--------|------|-----------|------------|
| Public | ALB, NAT Gateway | +0 (line 5) | IGW 직접 (line 68-72) |
| App (Private) | EKS 노드 | +10 (line 6) | NAT Gateway (line 135-141) |
| DB (Private) | RDS PostgreSQL | +20 (line 7) | 없음 (line 166-179) |
| Cache (Private) | ElastiCache Redis | +30 (line 8) | 없음 (DB와 동일 RT 공유, line 197-202) |
| Streaming (Private) | MSK, Lambda Worker | +40 (line 9) | NAT Gateway (line 230-236) |

- DB/Cache 서브넷에는 NAT Gateway 라우트가 없어 **아웃바운드 인터넷 접근이 완전히 차단**된다.
- Public 서브넷의 `map_public_ip_on_launch = true`는 ALB용이다 (line 52).
- HA를 위해 AZ별 NAT Gateway가 구성되어 있다 (line 96-105).

#### VPC Endpoints

AWS 서비스 접근 시 인터넷을 경유하지 않고 PrivateLink를 통해 직접 통신한다.
- 파일: `terraform/modules/vpc-endpoints/main.tf`

| 엔드포인트 유형 | 서비스 | 용도 |
|--------------|-------|------|
| Interface | EC2, ECR API, ECR DKR | EKS 노드, 컨테이너 이미지 풀 |
| Interface | EKS | EKS API 접근 |
| Interface | STS | IRSA (IAM Roles for Service Accounts) |
| Interface | CloudWatch Logs | 로그 전송 |
| Interface | Secrets Manager | RDS Proxy, 앱 시크릿 |
| Interface | ELB, Auto Scaling | ALB, 노드 그룹 관리 |
| Gateway | S3 | 정적 자산 접근 (무료) |
| Gateway | DynamoDB | VWR 상태 관리 (무료) |

모든 Interface 엔드포인트는 VPC CIDR에서 443(HTTPS)만 허용하는 보안 그룹을 사용한다 (line 20-28).

---

## 4. 데이터 보안

### 4-1. 암호화

#### 저장 시 암호화 (Encryption at Rest)

| 리소스 | 암호화 설정 | 파일:라인 |
|--------|-----------|---------|
| RDS PostgreSQL | `storage_encrypted = true` | `terraform/modules/rds/main.tf:59` |
| ElastiCache Redis | `at_rest_encryption_enabled = true` | `terraform/modules/elasticache/main.tf:112` |
| MSK (Kafka) | `encryption_at_rest_kms_key_arn = var.kms_key_arn` | `terraform/modules/msk/main.tf:167` |
| S3 (Frontend) | `sse_algorithm = "AES256"`, `bucket_key_enabled = true` | `terraform/modules/s3/main.tf:31-36` |
| S3 (Logs) | `sse_algorithm = "AES256"` | `terraform/modules/s3/main.tf:141-148` |
| EKS Secrets | KMS 키 기반 암호화 (제공 시) | `terraform/modules/eks/main.tf:114-122` |
| DynamoDB (VWR) | AWS 기본 암호화 (DynamoDB 관리형) | `terraform/modules/dynamodb-vwr/main.tf:6-23` |
| Terraform State | S3 `encrypt = true` | `terraform/environments/prod/main.tf:16` |

#### 전송 중 암호화 (Encryption in Transit)

| 구간 | TLS 설정 | 파일:라인 |
|------|---------|---------|
| Client -> CloudFront | `viewer_protocol_policy = "redirect-to-https"`, TLS 1.2 최소 | `terraform/modules/cloudfront/main.tf:137,237` |
| CloudFront -> ALB | `origin_protocol_policy = "https-only"`, `origin_ssl_protocols = ["TLSv1.2"]` | `terraform/modules/cloudfront/main.tf:98-99` |
| ALB HTTPS Listener | `ssl_policy = "ELBSecurityPolicy-TLS13-1-2-2021-06"` (TLS 1.3 지원) | `terraform/modules/alb/main.tf:194` |
| ElastiCache Redis | `transit_encryption_enabled = true` | `terraform/modules/elasticache/main.tf:113` |
| MSK (Kafka) | `client_broker = "TLS"` (prod), `in_cluster = true` | `terraform/modules/msk/main.tf:162-165` |
| RDS Proxy -> RDS | `require_tls = true` | `terraform/modules/rds/main.tf:163` |

#### KMS 사용

- EKS Secrets 암호화: `var.kms_key_arn`이 제공되면 K8s Secrets를 KMS로 암호화한다 (`terraform/modules/eks/main.tf:114-122`).
- MSK: `encryption_at_rest_kms_key_arn`으로 Kafka 데이터 KMS 암호화 (`terraform/modules/msk/main.tf:167`).

### 4-2. 시크릿 관리

#### AWS Secrets Manager

Terraform `secrets` 모듈에서 다음 시크릿을 생성한다.
- 파일: `terraform/modules/secrets/main.tf`

| 시크릿 | 생성 방법 | 길이 | 용도 |
|--------|---------|------|------|
| RDS Credentials | `random_password` (special=true) | 32자 | PostgreSQL 마스터 비밀번호 (line 5-8) |
| Redis Auth Token | `random_password` (special=false) | 32자 | ElastiCache 인증 (line 34-37) |
| Queue Entry Token Secret | `random_password` (special=false) | 64자 | VWR/Queue 토큰 HMAC 서명 (line 58-61) |
| JWT Secret | `random_password` (special=false) | 64자 | auth-service JWT 서명 (line 82-85) |

#### K8s Secrets

프로덕션 환경에서는 Kustomize `secretGenerator`를 통해 `secrets.env` 파일에서 K8s Secret을 생성한다.
- 파일: `k8s/spring/overlays/prod/kustomization.yaml:31-34`
```yaml
secretGenerator:
  - name: spring-prod-secret
    envs:
      - secrets.env
```

#### 시크릿 흐름: Terraform -> K8s -> Spring Boot

1. **Terraform**: `random_password`로 시크릿 생성 -> AWS Secrets Manager에 저장
2. **K8s**: `secrets.env` 파일에서 시크릿을 읽어 K8s Secret 오브젝트 생성 (CI/CD 파이프라인에서 Secrets Manager에서 추출하여 `secrets.env`에 주입)
3. **Spring Boot**: 환경변수로 주입 (`${JWT_SECRET}`, `${INTERNAL_API_TOKEN}`, `${QUEUE_ENTRY_TOKEN_SECRET}` 등)
   - 파일: `services-spring/auth-service/src/main/resources/application.yml:56`
   - 파일: `services-spring/gateway-service/src/main/resources/application.yml:113`

---

## 5. 웹 보안

### 5-1. WAF

파일: `terraform/modules/waf/main.tf`

AWS WAFv2 Web ACL이 CloudFront에 연결되어 있다 (scope: `CLOUDFRONT`, `us-east-1`).

#### WAF 규칙 (우선순위 순)

| 우선순위 | 규칙 이름 | 유형 | 동작 | 설명 |
|---------|----------|------|------|------|
| 1 | `rate-limit` | IP 기반 Rate Limiting | Block | 5분간 IP당 2000 요청 초과 시 차단 (line 25-45) |
| 2 | `aws-managed-common` | AWS Managed Rule | 적용 (none override) | AWSManagedRulesCommonRuleSet (line 48-68) |
| 3 | `aws-managed-bad-inputs` | AWS Managed Rule | 적용 | AWSManagedRulesKnownBadInputsRuleSet (line 71-91) |
| 4 | `aws-managed-sqli` | AWS Managed Rule | 적용 | AWSManagedRulesSQLiRuleSet (line 94-114) |

- 기본 동작: `allow` (line 20-22)
- Rate Limit 기본값: 2000 요청/5분 (`terraform/modules/waf/variables.tf:9`)
- 모든 규칙에 CloudWatch 메트릭이 활성화되어 있다.

#### Managed Rule Groups 상세

- **AWSManagedRulesCommonRuleSet**: OWASP Top 10 대응, Cross-site scripting (XSS), 경로 탐색, HTTP 프로토콜 위반 등 탐지
- **AWSManagedRulesKnownBadInputsRuleSet**: Log4j/JNDI 공격, 알려진 악성 입력 패턴 차단
- **AWSManagedRulesSQLiRuleSet**: SQL Injection 패턴 탐지 및 차단

### 5-2. CloudFront 보안

파일: `terraform/modules/cloudfront/main.tf`

#### Lambda@Edge 대기열 검증

- 모든 `/api/*` 경로에 Lambda@Edge `viewer-request` 함수가 연결되어 있다 (line 158-162).
- Lambda@Edge는 2계층 VWR 토큰 검증을 수행한다.
  - **Tier 1**: VWR이 활성화된 이벤트에 대해 `urr-vwr-token` 쿠키를 검증한다 (CDN 레벨 대기열).
  - **Tier 2**: 보호된 API 경로에 대해 `urr-entry-token` 쿠키 또는 `x-queue-entry-token` 헤더를 검증한다.
  - 파일: `lambda/edge-queue-check/index.js:70-129`
- JWT 서명 검증에 `crypto.timingSafeEqual()`을 사용한다 (타이밍 공격 방지).
  - 파일: `lambda/edge-queue-check/index.js:163-164`

#### Origin Access Control (OAC)

S3 오리진에 대해 OAC를 사용하여 CloudFront만 S3 버킷에 접근할 수 있다.
- `signing_behavior = "always"`, `signing_protocol = "sigv4"`
  - 파일: `terraform/modules/cloudfront/main.tf:70-76`
- S3 버킷 정책에서 `AWS:SourceArn` 조건으로 CloudFront 배포의 ARN을 확인한다.
  - 파일: `terraform/modules/s3/main.tf:92-117`

#### Custom Header 검증 (CloudFront -> ALB)

ALB가 CloudFront를 통해서만 접근 가능하도록 커스텀 헤더를 사용한다.
- CloudFront에서 `X-Custom-Header`에 비밀 값을 주입한다 (line 103-105).
- ALB Security Group에서 CloudFront managed prefix list만 허용한다 (line 21-30 of alb/main.tf).
- 이중 보호: prefix list + custom header

#### TLS 설정

- `minimum_protocol_version = "TLSv1.2_2021"` (line 236)
- `ssl_support_method = "sni-only"` (line 235)

### 5-3. CSP 및 보안 헤더

#### Content Security Policy (프론트엔드 미들웨어)

파일: `apps/web/src/middleware.ts:10-18`

```
default-src 'self'
script-src 'self' 'unsafe-inline' https://accounts.google.com https://apis.google.com
style-src 'self' 'unsafe-inline' 'nonce-{nonce}' https://accounts.google.com
img-src 'self' data: https:
connect-src 'self' http://localhost:* https://*.urr.guru https://accounts.google.com
frame-src https://accounts.google.com
frame-ancestors 'none'
```

- `script-src 'unsafe-inline'`: Next.js RSC 페이로드의 인라인 스크립트 때문에 필요하다 (주석 참조, line 8-9).
- Nonce 생성: `crypto.randomUUID()`를 Base64 인코딩하여 스타일 태그에 적용한다 (line 5).

#### 보안 헤더 (프론트엔드 미들웨어)

파일: `apps/web/src/middleware.ts:24-28`

| 헤더 | 값 | 설명 |
|------|---|------|
| `X-Frame-Options` | `DENY` | 클릭재킹 방지 |
| `X-Content-Type-Options` | `nosniff` | MIME 스니핑 방지 |
| `Referrer-Policy` | `strict-origin-when-cross-origin` | 리퍼러 정보 제한 |
| `Permissions-Policy` | `camera=(), microphone=(), geolocation=(), payment=()` | 브라우저 기능 제한 |

#### 보안 헤더 (CloudFront Response Headers Policy)

파일: `terraform/modules/cloudfront/main.tf:361-411`

CloudFront에서도 보안 헤더를 별도로 설정하여 이중 방어한다.

| 헤더 | 값 |
|------|---|
| `Strict-Transport-Security` | `max-age=31536000; includeSubDomains; preload` (line 367-370) |
| `X-Content-Type-Options` | nosniff (line 374) |
| `X-Frame-Options` | `DENY` (line 378-379) |
| `X-XSS-Protection` | `1; mode=block` (line 383-385) |
| `Referrer-Policy` | `strict-origin-when-cross-origin` (line 389-390) |

### 5-4. CORS

#### Gateway CORS 설정

파일: `services-spring/gateway-service/src/main/java/guru/urr/gatewayservice/config/CorsConfig.java:14-33`

| 설정 | 값 |
|------|---|
| Allowed Origins | `${CORS_ALLOWED_ORIGINS:http://localhost:3000}` (쉼표 구분) |
| Allowed Methods | `GET, POST, PUT, DELETE, PATCH, OPTIONS` |
| Allowed Headers | `Authorization, Content-Type, x-queue-entry-token` |
| Allow Credentials | `true` |
| Max Age | `3600`초 |

- 오리진은 환경변수로 동적 설정되며, 프로덕션에서는 실제 도메인만 허용한다.
- `allowCredentials = true`와 함께 와일드카드(`*`) 오리진은 사용하지 않아 보안 정책을 준수한다.

#### CloudFront CORS 설정

파일: `terraform/modules/cloudfront/main.tf:394-411`
- `access_control_allow_origins`: `var.cors_allowed_origins` (명시적 오리진 목록)
- `access_control_allow_credentials = true`
- `origin_override = false`: 오리진 서버의 CORS 헤더를 덮어쓰지 않는다.

---

## 6. 대기열 보안

### VWR 토큰 우회 방지 메커니즘

대기열 시스템은 2계층(Tier) 토큰 체계로 우회를 방지한다.

#### Tier 1: CDN 레벨 (Lambda@Edge)

- VWR이 활성화된 이벤트에 대해 `urr-vwr-token` 쿠키를 검증한다.
- 토큰이 없거나 유효하지 않으면 `/vwr/{eventId}` 대기 페이지로 302 리다이렉트한다.
- 토큰의 `tier` 클레임이 1이어야 하고, `sub`가 eventId와 일치해야 한다.
- 파일: `lambda/edge-queue-check/index.js:82-97`

#### Tier 2: 애플리케이션 레벨 (Gateway VwrEntryTokenFilter)

파일: `services-spring/gateway-service/src/main/java/guru/urr/gatewayservice/filter/VwrEntryTokenFilter.java:28-142`

- **보호 경로**: `/api/seats/*`, `/api/reservations*` (line 115-117)
- **보호 메서드**: `GET, POST, PUT, PATCH` (line 35)

#### Queue Entry Token HMAC 검증

- `QUEUE_ENTRY_TOKEN_SECRET`으로 HMAC-SHA256 서명된 JWT를 검증한다 (line 82-87).
- 최소 키 길이 32바이트 검증 (line 135-137).
- 토큰 생성: `QueueService.generateEntryToken()` -- `sub`(eventId), `uid`(userId), `iat`, `exp` 클레임 포함
  - 파일: `services-spring/queue-service/src/main/java/guru/urr/queueservice/service/QueueService.java:224-236`
- 토큰 TTL: 기본 600초(10분), `queue.entry-token.ttl-seconds`로 설정 가능
  - 파일: `services-spring/queue-service/src/main/java/guru/urr/queueservice/service/QueueService.java:48`

#### 사용자 위조 방지

- VWR Entry Token의 `uid` 클레임과 JWT 인증된 사용자의 `X-User-Id`를 교차 검증한다.
- 불일치 시 403 Forbidden을 반환한다.
- 파일: `services-spring/gateway-service/src/main/java/guru/urr/gatewayservice/filter/VwrEntryTokenFilter.java:89-99`

#### CloudFront 우회 방지

- CloudFront 비밀 헤더(`X-CloudFront-Verified`)가 일치하면 Lambda@Edge에서 이미 검증된 것으로 간주하여 Gateway에서 재검증을 생략한다.
- 타이밍 세이프 비교를 사용한다.
- 파일: `services-spring/gateway-service/src/main/java/guru/urr/gatewayservice/filter/VwrEntryTokenFilter.java:63-72`

### Rate Limiting (대기열 진입)

파일: `services-spring/gateway-service/src/main/java/guru/urr/gatewayservice/filter/RateLimitFilter.java:24-171`

Redis 기반 슬라이딩 윈도우 Rate Limiting이 카테고리별로 적용된다.

| 카테고리 | 기본 RPM | 대상 경로 |
|---------|---------|----------|
| AUTH | 60 | `/api/auth/**` |
| QUEUE | 120 | `/api/queue/**` |
| BOOKING | 30 | `/api/seats/reserve`, `/api/reservations` |
| GENERAL | 3000 | 나머지 모든 경로 |

- 기본값: `services-spring/gateway-service/src/main/resources/application.yml:126-130`
- 클라이언트 식별: 인증된 사용자는 `user:{userId}`, 비인증은 `ip:{remoteAddr}` (line 120-128)
- Redis 장애 시 인메모리 `ConcurrentHashMap` 폴백으로 동작한다 (limit x2 적용, line 100-114).
- `/api/auth/me`, `/health`, `/actuator/**`는 Rate Limiting에서 제외된다 (line 58-62).

---

## 7. 취약점 스캐닝

### Trivy 컨테이너 스캐닝 (CI/CD)

파일: `/.github/workflows/reusable-spring-ci-cd.yml:186-193`

```yaml
- name: Run security scan (Trivy)
  uses: aquasecurity/trivy-action@master
  with:
    image-ref: ${{ steps.login-ecr.outputs.registry }}/${{ inputs.ecr-repository }}:${{ steps.meta.outputs.image-tag }}
    format: 'sarif'
    output: 'trivy-results.sarif'
    severity: 'CRITICAL,HIGH'
    exit-code: '1'
```

- **실행 시점**: ECR에 이미지 푸시 후 스캔 (build-and-push job 내)
- **심각도 기준**: `CRITICAL`, `HIGH` 취약점만 검출
- **차단 정책**: `exit-code: '1'` -- CRITICAL/HIGH 취약점 발견 시 파이프라인 실패
- **출력 형식**: SARIF (GitHub Security 탭과 연동 가능)
- **적용 범위**: 모든 Spring Boot 서비스 (`reusable-spring-ci-cd.yml`을 호출하는 각 서비스별 CI/CD 워크플로우)

### 의존성 취약점 관리

- Trivy는 OS 패키지뿐 아니라 Java JAR(Gradle 의존성)도 스캔한다.
- 현재 별도의 Dependabot 또는 Renovate 설정은 확인되지 않는다.

---

## 8. 평가

### 잘된 점 (Strengths)

**S1. Gateway에서의 중앙화된 인증 + 헤더 스푸핑 방지**
- Gateway `JwtAuthFilter`가 외부 X-User-* 헤더를 먼저 제거한 후 JWT 검증 결과를 주입한다. 다운스트림 서비스는 JWT 시크릿 없이 헤더만으로 인증을 처리하여 시크릿 확산을 방지한다.
- 파일: `services-spring/gateway-service/src/main/java/guru/urr/gatewayservice/filter/JwtAuthFilter.java:53-54,104-137`

**S2. Refresh Token 로테이션 + 패밀리 기반 탈취 탐지**
- 단일 사용 Refresh Token, 패밀리 ID 기반 재사용 탐지, 탈취 시 전체 패밀리 폐기까지 구현되어 업계 권장 사항을 충실히 반영하였다.
- 파일: `services-spring/auth-service/src/main/java/guru/urr/authservice/service/AuthService.java:113-153`

**S3. 타이밍 세이프 토큰 비교의 일관된 적용**
- 모든 내부 토큰 검증에서 `MessageDigest.isEqual()`을 사용하고, Lambda@Edge에서도 `crypto.timingSafeEqual()`을 사용한다. 타이밍 공격을 전면 차단하고 있다.

**S4. 포괄적인 K8s Network Policies**
- Default Deny + 서비스별 최소 권한 Ingress/Egress 정책으로 Lateral Movement를 효과적으로 제한한다.
- 파일: `k8s/spring/base/network-policies.yaml`

**S5. 2계층 VWR 토큰 체계**
- CDN 레벨(Lambda@Edge)과 애플리케이션 레벨(Gateway)에서 이중으로 대기열 토큰을 검증하여, 사용자-이벤트 바인딩까지 확인한다.

**S6. CloudFront -> ALB 직접 접근 차단**
- Managed prefix list + custom header 이중 보호, `drop_invalid_header_fields = true` 설정.
- ALB SSL 정책에 TLS 1.3을 지원하는 최신 정책(`ELBSecurityPolicy-TLS13-1-2-2021-06`)을 사용한다.

**S7. 전구간 전송 암호화**
- Client -> CloudFront -> ALB -> Service, Redis, Kafka, RDS Proxy 모든 구간에서 TLS를 적용한다.
- HSTS preload까지 설정되어 있다.

**S8. 저장 시 암호화 전면 적용**
- RDS, ElastiCache, MSK, S3, EKS Secrets, Terraform State 모두 암호화가 활성화되어 있다.

**S9. 관리자 행위 감사 로그**
- AOP 기반 `@AuditLog`로 관리자의 모든 변경 행위를 DB에 기록한다.

**S10. 카테고리별 Rate Limiting + Redis 폴백**
- AUTH/QUEUE/BOOKING/GENERAL 카테고리별 차등 Rate Limiting과 Redis 장애 시 인메모리 폴백이 구현되어 있다.

### 미흡한 점 (Weaknesses/Gaps)

**W1. `script-src 'unsafe-inline'` CSP 정책**
- Next.js RSC의 제한으로 `'unsafe-inline'`이 허용되어 있어, CSP의 XSS 방어 효과가 크게 감소한다.
- 파일: `apps/web/src/middleware.ts:12`
- 권장: Next.js의 nonce 기반 인라인 스크립트 지원을 검토하거나, `strict-dynamic`을 사용하는 것을 고려해야 한다.

**W2. CSRF 보호가 전적으로 SameSite 쿠키에 의존**
- auth-service에서 CSRF 보호가 비활성화되어 있다 (`csrf.disable()`, `SecurityConfig.java:34`).
- `SameSite: Lax` 설정은 GET 기반 cross-site 요청에서 쿠키를 전송하므로, GET 요청으로 상태 변경이 가능한 엔드포인트가 있다면 위험할 수 있다.
- 현재 대부분의 상태 변경은 POST이므로 `Lax` 정책에 의해 보호되나, 명시적 CSRF 토큰 없이 쿠키 인증만 사용하는 것은 방어 심층성(Defense in Depth) 관점에서 부족하다.

**W3. VWR API Gateway 엔드포인트에 인증 부재**
- VWR API Gateway의 모든 메서드에 `authorization = "NONE"`이 설정되어 있다.
- 파일: `terraform/modules/api-gateway-vwr/main.tf:41,80,118`
- `/vwr/assign/{eventId}`에 인증 없이 접근 가능하여 대규모 봇 공격에 노출될 수 있다. API Gateway throttling(burst 10000, rate 5000)만으로 방어한다.

**W4. Queue Entry Token의 일회성 미보장**
- 코드 주석에서 "Entry Token is expiration-based one-time use. For strict one-time enforcement, consider tracking JWT jti claims in Redis SET with TTL."이라고 명시하고 있다.
- 파일: `services-spring/gateway-service/src/main/java/guru/urr/gatewayservice/filter/VwrEntryTokenFilter.java:24-25`
- 만료 시간 내에 동일 토큰으로 여러 번 요청할 수 있어, 토큰 공유/재사용이 가능하다.

**W5. Dependabot / 자동 의존성 업데이트 미설정**
- Trivy로 빌드 시점의 취약점은 검출하지만, 지속적인 의존성 모니터링을 위한 Dependabot 또는 Renovate 설정이 확인되지 않는다.

**W6. 로그인 실패 횟수 제한 미구현**
- Rate Limiting이 `/api/auth/**` 경로에 60 RPM으로 적용되어 있지만, 계정별 로그인 실패 횟수 추적이나 계정 잠금 메커니즘이 구현되어 있지 않다.
- 분산 브루트 포스 공격에 대한 방어가 부족하다.

**W7. Cookie Domain 미설정**
- 쿠키에 `domain` 속성이 명시적으로 설정되지 않아 브라우저 기본값이 적용된다. 서브도메인 간 쿠키 공유가 필요한 경우 문제가 될 수 있다.
- 파일: `services-spring/auth-service/src/main/java/guru/urr/authservice/util/CookieHelper.java` -- domain 설정 코드 없음

**W8. MSK Plaintext 옵션 존재**
- MSK 모듈에 `enable_plaintext` 변수가 존재하여, 설정 실수 시 암호화되지 않은 Kafka 통신이 가능하다. 프로덕션에서는 `enable_plaintext = false`로 설정되어 있으나 (`terraform/environments/prod/main.tf:194`), 변수 수준의 기본값 강제가 바람직하다.

### AWS 배포 시 보완 가능한 점

**R1. AWS WAF Bot Control 추가**
- 현재 WAF에 `AWSManagedRulesBotControlRuleSet`가 포함되어 있지 않다. 티켓팅 시스템 특성상 봇 트래픽 차단이 중요하므로 추가를 권장한다.
- `terraform/modules/waf/main.tf`에 추가 규칙 블록을 정의하면 된다.

**R2. AWS Secrets Manager 자동 로테이션**
- 현재 시크릿이 생성 후 수동으로 관리되고 있다. RDS 자격 증명에 대한 자동 로테이션 Lambda를 설정하면 보안성이 향상된다.

**R3. AWS GuardDuty / Security Hub 통합**
- EKS, S3, RDS에 대한 실시간 위협 탐지를 위해 GuardDuty를 활성화하고, Security Hub로 보안 상태를 중앙 관리하는 것을 권장한다.

**R4. RDS IAM 인증 도입**
- 현재 RDS 접근에 사용자명/비밀번호를 사용한다 (`iam_auth = "DISABLED"`, `terraform/modules/rds/main.tf:156`).
- EKS Pod에서 IRSA를 통한 IAM 인증으로 전환하면 비밀번호 관리 부담을 줄일 수 있다.

**R5. CSP 리포팅 엔드포인트 설정**
- `report-uri` 또는 `report-to` 디렉티브를 추가하여 CSP 위반 사항을 모니터링할 수 있다.

**R6. VWR Entry Token 일회성 강제**
- Redis SET에 JWT `jti` 클레임을 저장하고 TTL을 설정하여 토큰 재사용을 방지할 수 있다. 이미 코드 주석에서 이 방안을 제안하고 있다.
  - 파일: `services-spring/gateway-service/src/main/java/guru/urr/gatewayservice/filter/VwrEntryTokenFilter.java:25`

**R7. 계정 잠금 / Progressive Delay 도입**
- 로그인 실패 시 Redis에 실패 카운트를 저장하고, 임계값 초과 시 일정 시간 계정 잠금 또는 CAPTCHA를 적용하는 것을 권장한다.

**R8. Network Policy에 CIDR 기반 Egress 제한**
- 현재 `tier: data` 레이블 기반으로 데이터 계층 접근을 허용하고 있다. 외부 AWS 서비스(SQS, DynamoDB 등) 접근이 필요한 서비스에는 VPC Endpoint CIDR 범위로 Egress를 제한하면 더욱 강화할 수 있다.
