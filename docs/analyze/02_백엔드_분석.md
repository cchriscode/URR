# URR 백엔드 마이크로서비스 종합 분석

> 분석 기준일: 2026-02-17
> 분석 대상: `services-spring/` 디렉토리 전체 (8개 Spring Boot 마이크로서비스)

---

## 1. 기술 스택

### 1-1. 프레임워크 및 언어 버전

| 항목 | 버전 | 출처 |
|------|------|------|
| Spring Boot | 3.5.0 | 모든 서비스 `build.gradle` Line 3 (예: `services-spring/auth-service/build.gradle:3`) |
| Spring Cloud (Gateway) | 2025.0.1 | `services-spring/gateway-service/build.gradle:22` |
| Java | 21 (LTS) | 모든 서비스 `build.gradle`의 `languageVersion = JavaLanguageVersion.of(21)` (예: `services-spring/auth-service/build.gradle:13`) |
| Gradle | 8.14.4 | `services-spring/auth-service/.gradle/8.14.4/gc.properties` |

### 1-2. 서비스별 주요 의존성

| 서비스 | 핵심 의존성 |
|--------|------------|
| **auth-service** | Spring Data JPA, Spring Security, Flyway, Google API Client 2.7.2, jjwt 0.12.6, Lombok (`build.gradle:21-43`) |
| **gateway-service** | Spring Cloud Gateway Server WebMVC, Spring Data Redis, jjwt 0.12.6 (`build.gradle:25-37`) |
| **catalog-service** | Spring JDBC, Resilience4j 2.2.0, Flyway, AWS S3 SDK 2.31.68, Spotify Web API 8.4.1 (`build.gradle:21-43`) |
| **community-service** | Spring JDBC, Resilience4j 2.2.0, Flyway (`build.gradle:21-41`) |
| **payment-service** | Spring Data JPA, Resilience4j 2.2.0, Flyway, Spring Kafka (`build.gradle:21-46`) |
| **queue-service** | Spring Data Redis, AWS SQS SDK 2.29.0, AWS DynamoDB SDK 2.29.0, Resilience4j 2.2.0 (`build.gradle:21-41`) |
| **stats-service** | Spring Data JPA, Flyway, Spring Kafka (`build.gradle:21-40`) |
| **ticket-service** | Spring Data JPA, Spring Data Redis, Resilience4j 2.2.0, Flyway, Spring Kafka, AWS S3 SDK 2.31.68, Spotify Web API 8.4.1, Lombok (`build.gradle:21-51`) |

### 1-3. 공통 의존성

모든 서비스에 포함되는 의존성:
- `spring-boot-starter-actuator` - 헬스체크, Prometheus 메트릭
- `micrometer-registry-prometheus` - Prometheus 메트릭 수집
- `micrometer-tracing-bridge-brave` + `zipkin-reporter-brave` - 분산 추적
- `jjwt-api/impl/jackson 0.12.6` - JWT 파싱 (gateway에서 검증, 각 서비스에서 X-User-* 헤더 파싱)

### 1-4. 빌드 시스템

- **Gradle** (각 서비스 독립 프로젝트, 멀티모듈이 아닌 개별 `build.gradle`)
- 각 서비스에 `settings.gradle`이 별도 존재
- `group = 'com.urr'`, `version = '0.1.0'` 통일
- 테스트: JUnit Platform, 일부 서비스(auth, ticket)는 통합 테스트를 `integration` 태그로 분리
  - `services-spring/auth-service/build.gradle:51-60`
  - `services-spring/ticket-service/build.gradle:59-68`

---

## 2. MSA 구조

### 2-1. 8개 서비스 개요

| 서비스 | 포트 | 데이터베이스 | 역할 |
|--------|------|------------|------|
| **gateway-service** | 3001 | Redis (캐시/Rate Limit) | API Gateway, JWT 검증, 라우팅, Rate Limiting |
| **ticket-service** | 3002 | ticket_db (PostgreSQL 5434) + Redis | 예매, 좌석, 양도, 멤버십, 이벤트 핵심 도메인 |
| **payment-service** | 3003 | payment_db (PostgreSQL 5435) | 결제 처리, Toss 연동, 환불 |
| **stats-service** | 3004 | stats_db (PostgreSQL 5436) | 통계 집계, Kafka 이벤트 소비 |
| **auth-service** | 3005 | auth_db (PostgreSQL 5438) | 사용자 인증/인가, JWT 발급, Google OAuth |
| **queue-service** | 3007 | Redis + DynamoDB (VWR) | 대기열 관리, 입장 토큰 발급, SQS 연동 |
| **community-service** | 3008 | community_db (PostgreSQL 5437) | 커뮤니티 게시판, 댓글, 뉴스 |
| **catalog-service** | 3009 | catalog_db (PostgreSQL 5432) | 이벤트/아티스트 카탈로그, 관리자 기능, S3 이미지 업로드 |

출처:
- 포트: 각 서비스 `application.yml`의 `server.port` (예: `services-spring/gateway-service/src/main/resources/application.yml:78`)
- DB: `services-spring/docker-compose.databases.yml:1-74`

### 2-2. 서비스 의존성 맵 (동기 호출)

```
                         +-----------+
                         |  Frontend |
                         +-----+-----+
                               |
                    +----------v----------+
                    |   gateway-service   |
                    | (JWT검증, Rate Limit)|
                    +---+---+---+---+----+
                        |   |   |   |
          +-------------+   |   |   +------------------+
          |                 |   |                       |
    +-----v-----+   +------v---v---+   +--------+  +---v----+
    |auth-service|   |ticket-service|   |queue-  |  |catalog-|
    |            |<--|              |   |service  |  |service |
    +------------+   +------+-------+   +---+----+  +---+----+
                            |               |            |
                     +------v------+        |     +------v------+
                     |payment-     |        |     | community-  |
                     |service      |--------+     | service     |
                     +------+------+              +------+------+
                            |                            |
                     +------v------+                     |
                     |stats-service |<----(Kafka)--------+
                     +-------------+         (ticket-service가 Kafka 생산)
```

**동기 호출 관계 (RestClient + Internal API Token):**

| 호출자 | 호출 대상 | 용도 | 출처 |
|--------|----------|------|------|
| payment-service | ticket-service | 예매 검증, 예매 확정, 양도/멤버십 검증 | `services-spring/payment-service/src/main/java/guru/urr/paymentservice/client/TicketInternalClient.java:39-93` |
| ticket-service | payment-service | 결제 상태 조회 (Reconciliation) | `services-spring/ticket-service/src/main/java/guru/urr/ticketservice/shared/client/PaymentInternalClient.java:38-44` |
| catalog-service | auth-service | 사용자 정보 일괄 조회 | `services-spring/catalog-service/src/main/java/guru/urr/catalogservice/shared/client/AuthInternalClient.java` |
| catalog-service | ticket-service | 티켓/좌석/예매 데이터 조회 | `services-spring/catalog-service/src/main/java/guru/urr/catalogservice/shared/client/TicketInternalClient.java` |
| community-service | ticket-service | 아티스트 정보 조회 | `services-spring/community-service/src/main/java/guru/urr/communityservice/shared/client/TicketInternalClient.java` |
| queue-service | ticket-service | 이벤트 대기열 정보 조회 | `services-spring/queue-service/src/main/java/guru/urr/queueservice/shared/client/TicketInternalClient.java` |

### 2-3. Gateway 라우팅 설정

`services-spring/gateway-service/src/main/resources/application.yml:8-75`

Spring Cloud Gateway MVC 라우터 설정 (총 15개 라우트):

| Route ID | URI | Path Predicate |
|----------|-----|----------------|
| auth | auth-service:3005 | `/api/v1/auth/**`, `/api/auth/**` |
| payment | payment-service:3003 | `/api/v1/payments/**`, `/api/payments/**` |
| stats | stats-service:3004 | `/api/v1/stats/**`, `/api/stats/**` |
| events | catalog-service:3009 | `/api/v1/events/**`, `/api/events/**` |
| tickets | ticket-service:3002 | `/api/v1/tickets/**`, `/api/tickets/**` |
| seats | ticket-service:3002 | `/api/v1/seats/**`, `/api/seats/**` |
| reservations | ticket-service:3002 | `/api/v1/reservations/**`, `/api/reservations/**` |
| queue | queue-service:3007 | `/api/v1/queue/**`, `/api/queue/**` |
| admin | catalog-service:3009 | `/api/v1/admin/**`, `/api/admin/**` |
| community | community-service:3008 | `/api/v1/community/**`, `/api/community/**` |
| news | community-service:3008 | `/api/v1/news/**`, `/api/news/**` |
| artists | catalog-service:3009 | `/api/v1/artists/**`, `/api/artists/**` |
| memberships | ticket-service:3002 | `/api/v1/memberships/**`, `/api/memberships/**` |
| transfers | ticket-service:3002 | `/api/v1/transfers/**`, `/api/transfers/**` |
| image | catalog-service:3009 | `/api/v1/image/**`, `/api/image/**` |
| time | ticket-service:3002 | `/api/v1/time/**`, `/api/time/**` |

API 버전 처리: `ApiVersionFilter`(`services-spring/gateway-service/src/main/java/guru/urr/gatewayservice/filter/ApiVersionFilter.java:20`)가 `/api/v1/` prefix를 `/api/`로 변환하여 다운스트림 서비스에 전달 (Order -10).

---

## 3. 서비스별 상세 분석

### 3-1. auth-service

**역할:** 사용자 인증, JWT 발급/검증, Google OAuth, Refresh Token Rotation

**REST 엔드포인트:**

| Method | Path | 설명 | 출처 |
|--------|------|------|------|
| POST | `/api/auth/register` | 회원가입 | `AuthController.java:39-46` |
| POST | `/api/auth/login` | 로그인 | `AuthController.java:48-55` |
| GET | `/api/auth/me` | 현재 사용자 조회 | `AuthController.java:57-60` |
| POST | `/api/auth/verify-token` | 토큰 검증 | `AuthController.java:62-65` |
| POST | `/api/auth/refresh` | Refresh Token 갱신 | `AuthController.java:67-83` |
| POST | `/api/auth/google` | Google OAuth 로그인 | `AuthController.java:85-101` |
| POST | `/api/auth/logout` | 로그아웃 (쿠키 삭제 + 토큰 폐기) | `AuthController.java:103-117` |
| GET | `/internal/users/{id}` | (내부) 사용자 ID로 조회 | `InternalUserController.java:32-42` |
| POST | `/internal/users/batch` | (내부) 사용자 일괄 조회 | `InternalUserController.java:44-61` |

(모든 파일 경로: `services-spring/auth-service/src/main/java/guru/urr/authservice/controller/`)

**데이터베이스 테이블:**

- `users` - 사용자 정보 (`V1__create_users_table.sql:3-12`)
  - `id` (UUID PK), `email` (UNIQUE), `password_hash`, `name`, `phone`, `google_id`, `role` ('user'/'admin')
- `refresh_tokens` - Refresh Token 추적 (`V4__refresh_tokens_table.sql:2-10`)
  - `id` (UUID PK), `user_id` (FK), `token_hash` (UNIQUE), `family_id`, `expires_at`, `revoked_at`

(파일 경로: `services-spring/auth-service/src/main/resources/db/migration/`)

**JPA 엔티티:**
- `UserEntity` (`services-spring/auth-service/src/main/java/guru/urr/authservice/domain/UserEntity.java:22-63`)
- `RefreshTokenEntity` (`services-spring/auth-service/src/main/java/guru/urr/authservice/domain/RefreshTokenEntity.java:14-54`)

**핵심 비즈니스 로직:**
- Refresh Token Rotation: 토큰 재사용 탐지 시 해당 family의 모든 토큰 폐기 (`AuthService.java:127-141`)
- Google OAuth: `GoogleIdTokenVerifier`를 통한 Google ID Token 검증 후 자동 회원가입/로그인 (`AuthService.java:197-259`)
- 비밀번호 해싱: Spring Security `PasswordEncoder` 사용 (`AuthService.java:97`)

---

### 3-2. gateway-service

**역할:** API Gateway, JWT 검증 및 사용자 헤더 주입, Cookie-to-Authorization 변환, Rate Limiting, VWR 입장 토큰 검증

**필터 체인 (Order 순):**

| Order | 필터 | 역할 | 출처 |
|-------|------|------|------|
| -10 | `ApiVersionFilter` | `/api/v1/` -> `/api/` 경로 변환 | `ApiVersionFilter.java:20` |
| -2 | `CookieAuthFilter` | `access_token` 쿠키를 Authorization 헤더로 변환 | `CookieAuthFilter.java:19` |
| -1 | `JwtAuthFilter` | JWT 검증, X-User-Id/Email/Role 헤더 주입, X-User-* 스푸핑 방지 | `JwtAuthFilter.java:35` |
| 0 | `RateLimitFilter` | Redis Lua 스크립트 기반 Rate Limiting (카테고리별) | `RateLimitFilter.java:24` |
| 1 | `VwrEntryTokenFilter` | 좌석 선택/예매 경로 보호 (x-queue-entry-token 검증) | `VwrEntryTokenFilter.java:28` |

(파일 경로: `services-spring/gateway-service/src/main/java/guru/urr/gatewayservice/filter/`)

**Rate Limit 카테고리:**

| 카테고리 | 기본값(RPM) | 대상 경로 | 출처 |
|----------|-----------|----------|------|
| AUTH | 60 | `/api/v1/auth/**` | `application.yml:122`, `RateLimitFilter.java:131-133` |
| QUEUE | 120 | `/api/v1/queue/**` | `application.yml:123`, `RateLimitFilter.java:135-137` |
| BOOKING | 30 | `/api/v1/seats/reserve`, `/api/v1/reservations` | `application.yml:124`, `RateLimitFilter.java:139-142` |
| GENERAL | 3000 | 기타 모든 경로 | `application.yml:125`, `RateLimitFilter.java:144` |

Rate Limit 장애 시 인메모리 ConcurrentHashMap 기반 fallback 동작 (`RateLimitFilter.java:100-114`).

**CORS 설정:** `services-spring/gateway-service/src/main/java/guru/urr/gatewayservice/config/CorsConfig.java:20-33`
- 허용 메서드: GET, POST, PUT, DELETE, PATCH, OPTIONS
- 허용 헤더: Authorization, Content-Type, x-queue-entry-token
- Credentials 허용, Max-Age: 3600초

---

### 3-3. catalog-service

**역할:** 이벤트/아티스트 카탈로그 읽기, 관리자(Admin) CRUD, S3 이미지 업로드, Spotify 아티스트 정보 연동

**REST 엔드포인트:**

| Method | Path | 설명 | 인가 | 출처 |
|--------|------|------|------|------|
| GET | `/api/events` | 이벤트 목록 조회 (검색, 페이징) | Public | `EventController.java:22-30` |
| GET | `/api/events/{id}` | 이벤트 상세 조회 | Public | `EventController.java:32-35` |
| GET | `/api/artists` | 아티스트 목록 | Public | `ArtistController.java:30-35` |
| GET | `/api/artists/{id}` | 아티스트 상세 | Public | `ArtistController.java:37-40` |
| POST | `/api/artists/enrich` | Spotify 데이터 연동 | Admin | `ArtistController.java:42-47` |
| GET | `/api/admin/dashboard` | 대시보드 통계 | Admin | `AdminController.java:40-44` |
| GET | `/api/admin/seat-layouts` | 좌석 배치도 목록 | Admin | `AdminController.java:46-50` |
| POST | `/api/admin/events` | 이벤트 생성 | Admin | `AdminController.java:52-60` |
| PUT | `/api/admin/events/{id}` | 이벤트 수정 | Admin | `AdminController.java:62-71` |
| POST | `/api/admin/events/{id}/cancel` | 이벤트 취소 | Admin | `AdminController.java:73-81` |
| DELETE | `/api/admin/events/{id}` | 이벤트 삭제 | Admin | `AdminController.java:83-91` |
| POST | `/api/admin/events/{id}/generate-seats` | 좌석 자동 생성 | Admin | `AdminController.java:93-101` |
| DELETE | `/api/admin/events/{id}/seats` | 좌석 삭제 | Admin | `AdminController.java:103-111` |
| POST | `/api/admin/events/{eventId}/tickets` | 티켓 타입 생성 | Admin | `AdminController.java:113-122` |
| PUT | `/api/admin/tickets/{id}` | 티켓 타입 수정 | Admin | `AdminController.java:124-133` |
| GET | `/api/admin/reservations` | 예매 목록 조회 | Admin | `AdminController.java:135-144` |
| PATCH | `/api/admin/reservations/{id}/status` | 예매 상태 변경 | Admin | `AdminController.java:146-155` |

(파일 경로: `services-spring/catalog-service/src/main/java/guru/urr/catalogservice/domain/`)

**데이터베이스 (catalog_db) 테이블:**

`services-spring/catalog-service/src/main/resources/db/migration/V1__catalog_core_schema.sql:1-81`

- `seat_layouts` - 좌석 배치도 (JSON 기반 layout_config)
- `artists` - 아티스트 (name, image_url, membership_price)
- `events` - 이벤트 (title, venue, event_date, status, artist_id FK)
- `ticket_types` - 티켓 유형 (price, total_quantity, available_quantity)
- `keyword_mappings` - 한영 키워드 매핑 (검색용)
- `news` - 뉴스 (title, content, author)

**핵심 비즈니스 로직:**
- 관리자 감사 로그: `@AuditLog` 커스텀 AOP 어노테이션 (`services-spring/catalog-service/src/main/java/guru/urr/catalogservice/shared/audit/AdminAuditAspect.java`)
- Spotify 연동: `SpotifyService` (`services-spring/catalog-service/src/main/java/guru/urr/catalogservice/domain/artist/service/SpotifyService.java`)
- S3 이미지 업로드: `ImageUploadService` (`services-spring/catalog-service/src/main/java/guru/urr/catalogservice/domain/admin/service/ImageUploadService.java`)

---

### 3-4. community-service

**역할:** 아티스트별 커뮤니티 게시판, 댓글, 뉴스 관리

**REST 엔드포인트:**

| Method | Path | 설명 | 인가 | 출처 |
|--------|------|------|------|------|
| GET | `/api/community/posts` | 게시글 목록 | Public | `CommunityPostController.java:28-34` |
| GET | `/api/community/posts/{id}` | 게시글 상세 | Public | `CommunityPostController.java:36-39` |
| POST | `/api/community/posts` | 게시글 작성 | User | `CommunityPostController.java:41-47` |
| PUT | `/api/community/posts/{id}` | 게시글 수정 | User (본인) | `CommunityPostController.java:49-56` |
| DELETE | `/api/community/posts/{id}` | 게시글 삭제 | User (본인) | `CommunityPostController.java:58-64` |
| GET | `/api/community/posts/{postId}/comments` | 댓글 목록 | Public | `CommentController.java:27-32` |
| POST | `/api/community/posts/{postId}/comments` | 댓글 작성 | User | `CommentController.java:34-42` |
| DELETE | `/api/community/posts/{postId}/comments/{commentId}` | 댓글 삭제 | User (본인) | `CommentController.java:44-52` |
| GET | `/api/news` | 뉴스 목록 | Public | `NewsController.java:36-42` |
| GET | `/api/news/{id}` | 뉴스 상세 | Public | `NewsController.java:44-47` |
| POST | `/api/news` | 뉴스 작성 | Admin | `NewsController.java:49-56` |
| PUT | `/api/news/{id}` | 뉴스 수정 | Admin | `NewsController.java:58-66` |
| DELETE | `/api/news/{id}` | 뉴스 삭제 | Admin | `NewsController.java:68-76` |

(파일 경로: `services-spring/community-service/src/main/java/guru/urr/communityservice/controller/`)

**데이터베이스 (community_db) 테이블:**

- `news` - 뉴스 (`V1__community_schema.sql:3-13`)
- `community_posts` - 커뮤니티 게시글 (`V3__community_posts_comments.sql:2-14`)
  - `artist_id`, `author_id`, `title`, `content`, `views`, `comment_count`
- `community_comments` - 댓글 (`V3__community_posts_comments.sql:17-24`)
  - `post_id` (FK), `author_id`, `content`

(파일 경로: `services-spring/community-service/src/main/resources/db/migration/`)

---

### 3-5. payment-service

**역할:** 결제 준비/확인/환불, Toss Payments 연동, Kafka를 통한 결제 이벤트 발행

**REST 엔드포인트:**

| Method | Path | 설명 | 출처 |
|--------|------|------|------|
| POST | `/api/payments/prepare` | 결제 준비 (orderId 발급) | `PaymentController.java:33-40` |
| POST | `/api/payments/confirm` | 결제 확인 (Toss 결과 처리) | `PaymentController.java:42-49` |
| GET | `/api/payments/order/{orderId}` | 주문 ID로 결제 조회 | `PaymentController.java:51-58` |
| POST | `/api/payments/{paymentKey}/cancel` | 결제 취소/환불 | `PaymentController.java:60-68` |
| GET | `/api/payments/user/me` | 내 결제 내역 | `PaymentController.java:70-80` |
| POST | `/api/payments/process` | 통합 결제 처리 (prepare+confirm) | `PaymentController.java:82-89` |
| GET | `/internal/payments/by-reservation/{reservationId}` | (내부) 예매별 결제 조회 | `InternalPaymentController.java:30-57` |

(파일 경로: `services-spring/payment-service/src/main/java/guru/urr/paymentservice/controller/`)

**데이터베이스 (payment_db) 테이블:**

- `payments` - 결제 정보 (`V1__payment_schema.sql:3-25`)
  - `id`, `reservation_id`, `user_id`, `event_id`, `order_id` (UNIQUE), `payment_key` (UNIQUE)
  - `amount`, `method`, `status` (pending/confirmed/refunded)
  - Toss 관련: `toss_status`, `toss_approved_at`, `toss_receipt_url`, `toss_response` (JSONB)
  - 환불: `refund_amount`, `refund_reason`, `refunded_at`
- `payment_logs` - 결제 감사 로그 (`V1__payment_schema.sql:27-40`)
- 확장 컬럼: `payment_type` (reservation/transfer/membership), `reference_id` (`V2__payment_types.sql:2-3`)

(파일 경로: `services-spring/payment-service/src/main/resources/db/migration/`)

**핵심 비즈니스 로직:**
- 결제 유형별 분기: reservation, transfer, membership 3가지 타입 지원 (`PaymentService.java:57-77`)
- 동기+비동기 이중 확인: 내부 API로 동기 확인 후, Kafka로 비동기 이벤트 발행 (`PaymentService.java:343-376`)
- 멱등성: 기존 결제 존재 시 중복 생성 방지 (`PaymentService.java:84-106`)
- `FOR UPDATE`를 통한 비관적 잠금 (`PaymentService.java:122-127`)

---

### 3-6. queue-service

**역할:** 뒷단 대기열 관리, Redis ZSET 기반 대기 순서, 입장 토큰 발급, SQS/DynamoDB VWR 연동

**REST 엔드포인트:**

| Method | Path | 설명 | 인가 | 출처 |
|--------|------|------|------|------|
| POST | `/api/queue/check/{eventId}` | 대기열 진입/상태 확인 | User | `QueueController.java:29-37` |
| GET | `/api/queue/status/{eventId}` | 대기열 상태 폴링 | User | `QueueController.java:39-46` |
| POST | `/api/queue/heartbeat/{eventId}` | 대기열 하트비트 | User | `QueueController.java:48-55` |
| POST | `/api/queue/leave/{eventId}` | 대기열 이탈 | User | `QueueController.java:57-64` |
| GET | `/api/queue/admin/{eventId}` | 대기열 관리자 현황 | Admin | `QueueController.java:66-73` |
| POST | `/api/queue/admin/clear/{eventId}` | 대기열 초기화 | Admin | `QueueController.java:75-82` |
| POST | `/api/queue/admin/threshold/{eventId}` | 이벤트별 동시 접속 한도 설정 | Admin | `QueueController.java:84-93` |
| POST | `/api/admin/vwr/activate/{eventId}` | VWR 활성화 | Admin | `VwrAdminController.java:49-75` |
| POST | `/api/admin/vwr/deactivate/{eventId}` | VWR 비활성화 | Admin | `VwrAdminController.java:80-104` |
| GET | `/api/admin/vwr/status/{eventId}` | VWR 상태 조회 | Admin | `VwrAdminController.java:109-138` |
| POST | `/api/admin/vwr/advance/{eventId}` | Serving Counter 전진 | Admin | `VwrAdminController.java:143-184` |

(파일 경로: `services-spring/queue-service/src/main/java/guru/urr/queueservice/controller/`)

**핵심 비즈니스 로직:**
- Redis ZSET 기반 대기열: 순서(score) = timestamp 또는 VWR position (`QueueService.java:84-86`)
- 동적 폴링 간격: 대기 위치에 따라 1~60초 조절 (`QueueService.java:240-247`)
- 처리량 기반 대기 시간 추정: 최근 1분간의 입장 수를 기반으로 계산 (`QueueService.java:251-269`)
- 입장 토큰 생성: JWT 기반, eventId를 subject로, userId를 uid claim으로 포함 (`QueueService.java:224-236`)
- 이벤트별 임계값: Redis에 개별 이벤트 threshold 저장 (`QueueService.java:282-289`)
- Hash Tag: Redis Cluster slot affinity를 위해 `{eventId}:queue` 형식 사용 (`QueueService.java:293-307`)

---

### 3-7. stats-service

**역할:** Kafka 이벤트 소비를 통한 통계 집계, 관리자 대시보드 데이터 제공

**REST 엔드포인트:**

| Method | Path | 설명 | 출처 |
|--------|------|------|------|
| GET | `/api/stats/overview` | 전체 통계 개요 | `StatsController.java:26-30` |
| GET | `/api/stats/daily` | 일별 통계 | `StatsController.java:32-39` |
| GET | `/api/stats/events` | 이벤트별 통계 | `StatsController.java:41-49` |
| GET | `/api/stats/events/{eventId}` | 특정 이벤트 통계 | `StatsController.java:51-58` |
| GET | `/api/stats/payments` | 결제 통계 | `StatsController.java:60-64` |
| GET | `/api/stats/revenue` | 매출 통계 (기간별) | `StatsController.java:66-74` |
| GET | `/api/stats/users` | 사용자 통계 | `StatsController.java:76-83` |
| GET | `/api/stats/hourly-traffic` | 시간대별 트래픽 | `StatsController.java:85-92` |
| GET | `/api/stats/conversion` | 전환율 통계 | `StatsController.java:94-101` |
| GET | `/api/stats/cancellations` | 취소 통계 | `StatsController.java:103-110` |
| GET | `/api/stats/realtime` | 실시간 통계 | `StatsController.java:112-116` |
| GET | `/api/stats/seat-preferences` | 좌석 선호도 분석 | `StatsController.java:118-125` |
| GET | `/api/stats/user-behavior` | 사용자 행동 분석 | `StatsController.java:127-134` |
| GET | `/api/stats/performance` | 성능 메트릭 | `StatsController.java:136-140` |

(파일 경로: `services-spring/stats-service/src/main/java/guru/urr/statsservice/controller/StatsController.java`)
모든 엔드포인트는 Admin 권한 필요 (`jwtTokenParser.requireAdmin(request)`).

**데이터베이스 (stats_db) 테이블:**

- `daily_stats` - 일별 집계 (`V1__stats_schema.sql:3-17`)
  - `date` (UNIQUE), `total_reservations`, `confirmed_reservations`, `cancelled_reservations`, `total_revenue`, `new_users` 등
- `event_stats` - 이벤트별 집계 (`V1__stats_schema.sql:19-33`)
  - `event_id` (UNIQUE), `total_seats`, `reserved_seats`, `total_revenue`, `view_count` 등
- `processed_events` - 이벤트 중복 처리 방지 (`V2__processed_events_table.sql:2-5`)

(파일 경로: `services-spring/stats-service/src/main/resources/db/migration/`)

---

### 3-8. ticket-service

**역할:** 핵심 도메인 서비스 -- 좌석 예매, 예매 관리, 양도, 멤버십, 결제 이벤트 소비

**REST 엔드포인트:**

| Method | Path | 설명 | 출처 |
|--------|------|------|------|
| POST | `/api/reservations` | 예매 생성 (스탠딩) | `ReservationController.java:30-37` |
| GET | `/api/reservations/my` | 내 예매 목록 | `ReservationController.java:39-43` |
| GET | `/api/reservations/{id}` | 예매 상세 | `ReservationController.java:45-52` |
| POST | `/api/reservations/{id}/cancel` | 예매 취소 | `ReservationController.java:54-61` |
| GET | `/api/seats/layouts` | 좌석 배치도 목록 | `SeatController.java:33-36` |
| GET | `/api/seats/events/{eventId}` | 이벤트별 좌석 목록 | `SeatController.java:38-41` |
| POST | `/api/seats/reserve` | 좌석 예매 (지정석) | `SeatController.java:43-50` |
| GET | `/api/seats/reservation/{reservationId}` | 좌석 예매 상세 | `SeatController.java:52-59` |
| GET | `/api/tickets/event/{eventId}` | 이벤트별 티켓 타입 조회 | `TicketController.java:21-24` |
| GET | `/api/tickets/availability/{ticketTypeId}` | 티켓 잔여 수량 | `TicketController.java:26-29` |
| POST | `/api/transfers` | 양도 등록 | `TransferController.java:29-37` |
| GET | `/api/transfers` | 양도 가능 목록 | `TransferController.java:39-49` |
| GET | `/api/transfers/my` | 내 양도 목록 | `TransferController.java:51-55` |
| GET | `/api/transfers/{id}` | 양도 상세 | `TransferController.java:57-64` |
| POST | `/api/transfers/{id}/cancel` | 양도 취소 | `TransferController.java:66-73` |
| POST | `/api/memberships/subscribe` | 멤버십 가입 | `MembershipController.java:32-40` |
| GET | `/api/memberships/my` | 내 멤버십 목록 | `MembershipController.java:42-46` |
| GET | `/api/memberships/my/{artistId}` | 아티스트별 멤버십 | `MembershipController.java:48-55` |
| GET | `/api/memberships/benefits/{artistId}` | 멤버십 혜택 조회 | `MembershipController.java:57-64` |
| GET | `/api/time` | 서버 시간 조회 | `TimeController.java:13-16` |

**Internal 엔드포인트:**

| Method | Path | 설명 | 출처 |
|--------|------|------|------|
| GET | `/internal/reservations/{id}/validate` | 예매 검증 | `InternalReservationController.java:41-49` |
| POST | `/internal/reservations/{id}/confirm` | 예매 확정 | `InternalReservationController.java:51-61` |
| POST | `/internal/reservations/{id}/refund` | 예매 환불 처리 | `InternalReservationController.java:63-71` |
| GET | `/internal/transfers/{id}/validate` | 양도 검증 | `InternalReservationController.java:75-82` |
| POST | `/internal/transfers/{id}/complete` | 양도 완료 | `InternalReservationController.java:84-96` |
| GET | `/internal/memberships/{id}/validate` | 멤버십 검증 | `InternalReservationController.java:100-108` |
| POST | `/internal/memberships/{id}/activate` | 멤버십 활성화 | `InternalReservationController.java:110-118` |

(파일 경로: `services-spring/ticket-service/src/main/java/guru/urr/ticketservice/`)

**데이터베이스 (ticket_db) 테이블:**

- `seat_layouts` - 좌석 배치도 (`V1__ticket_core_schema.sql:4-12`)
- `events` - 이벤트 (`V1__ticket_core_schema.sql:14-31`)
- `ticket_types` - 티켓 유형 (`V1__ticket_core_schema.sql:33-43`)
- `seats` - 좌석 (`V1__ticket_core_schema.sql:45-57`)
  - 동시성 컬럼: `version` (낙관적 잠금), `fencing_token` (Redis 펜싱), `locked_by` (`V8__seats_concurrency_columns.sql:2-8`)
- `reservations` - 예매 (`V1__ticket_core_schema.sql:59-71`)
  - `idempotency_key` 컬럼 추가 (`V12__reservation_idempotency.sql:2`)
- `reservation_items` - 예매 항목 (`V1__ticket_core_schema.sql:73-82`)
- `artists` - 아티스트 (`V3__artists_table.sql`)
- `artist_memberships` - 멤버십 (`V4__membership_tables.sql:3-15`)
  - `user_id`, `artist_id`, `tier` (SILVER/GOLD/VIP), `points`, `status`
- `membership_point_logs` - 포인트 로그 (`V4__membership_tables.sql:17-25`)
- `ticket_transfers` - 양도 (`V5__ticket_transfers.sql:2-16`)
  - `seller_id`, `buyer_id`, `original_price`, `transfer_fee`, `total_price`, `status` (listed/sold/cancelled)
- `processed_events` - Kafka 이벤트 중복 처리 방지 (`V14__processed_events.sql:2-6`)

(파일 경로: `services-spring/ticket-service/src/main/resources/db/migration/`)

**스케줄러:**
- `ReservationCleanupScheduler`: 만료된 pending 예매를 정리 (30초 간격) (`services-spring/ticket-service/src/main/java/guru/urr/ticketservice/scheduling/ReservationCleanupScheduler.java:35-100`)
  - `FOR UPDATE SKIP LOCKED`로 동시 실행 방지 (Line 44)
- `PaymentReconciliationScheduler`: payment-service와 예매 상태 불일치 복구 (5분 간격) (`services-spring/ticket-service/src/main/java/guru/urr/ticketservice/scheduling/PaymentReconciliationScheduler.java:47-104`)

---

## 4. 데이터베이스 구조

### 4-1. Database-per-Service 패턴

| 서비스 | DB명 | 포트(로컬) | 스키마 관리 |
|--------|------|-----------|------------|
| auth-service | auth_db | 5438 | Flyway |
| ticket-service | ticket_db | 5434 | Flyway |
| payment-service | payment_db | 5435 | Flyway |
| stats-service | stats_db | 5436 | Flyway |
| community-service | community_db | 5437 | Flyway |
| catalog-service | catalog_db | 5432 | Flyway |

출처: `services-spring/docker-compose.databases.yml:1-45`

catalog-service와 ticket-service가 별도 DB를 사용하지만 유사한 테이블(events, ticket_types, seats, artists)을 각각 소유한다. catalog-service는 카탈로그 읽기 전용 데이터를, ticket-service는 예매/좌석 상태 변경 등 쓰기 중심 데이터를 관리한다.

### 4-2. JPA 엔티티와 관계

**auth-service (JPA 사용):**
- `UserEntity` (`services-spring/auth-service/src/main/java/guru/urr/authservice/domain/UserEntity.java:22`)
  - id(UUID), email, passwordHash, name, phone, googleId, role(ENUM), createdAt, updatedAt
- `RefreshTokenEntity` (`services-spring/auth-service/src/main/java/guru/urr/authservice/domain/RefreshTokenEntity.java:14`)
  - id(UUID), userId(UUID), tokenHash, familyId(UUID), expiresAt, revokedAt

**payment-service (JPA + JdbcTemplate 혼용):**
- `payments`, `payment_logs` 테이블을 JdbcTemplate으로 직접 조작
- JPA의 `hibernate.ddl-auto: validate`로 스키마 검증만 수행

**ticket-service (JdbcTemplate 사용):**
- JPA Entity를 정의하지 않고 `JdbcTemplate`/`NamedParameterJdbcTemplate`으로 SQL 직접 실행
- `hibernate.ddl-auto: validate`

**stats-service (JPA + JdbcTemplate 혼용):**
- `daily_stats`, `event_stats` 테이블
- JPA `validate` 모드

**catalog-service, community-service (JdbcTemplate 사용):**
- JPA 미사용, `spring-boot-starter-jdbc`만 사용
- Flyway로 스키마 관리

### 4-3. 마이그레이션 전략 (Flyway)

모든 서비스는 Flyway를 사용하며, `baseline-on-migrate: true` 설정이 공통 적용됨.

| 서비스 | 마이그레이션 파일 수 | 주요 파일 |
|--------|---------------------|----------|
| auth-service | 5개 (V1~V5) | users, google_id, admin seed, refresh_tokens, nullable password |
| ticket-service | 14개 (V1~V14) | core schema, seed data, artists, memberships, transfers, concurrency columns, idempotency, processed_events |
| payment-service | 3개 (V1~V3) | payment schema, payment types, indexes |
| stats-service | 2개 (V1~V2) | stats schema, processed_events |
| community-service | 3개 (V1~V3) | community schema, indexes, posts/comments |
| catalog-service | 1개 (V1) | catalog core schema |

---

## 5. MSA 통신 방식

### 5-1. 동기 통신 (REST)

**Internal API Token 인증:**

서비스 간 내부 통신은 `INTERNAL_API_TOKEN` 환경변수 기반의 공유 시크릿을 사용한다.

- 호출 측: `Authorization: Bearer {INTERNAL_API_TOKEN}` 헤더 추가
  - 예: `services-spring/payment-service/src/main/java/guru/urr/paymentservice/client/TicketInternalClient.java:41`
- 검증 측: `InternalTokenValidator.requireValidToken(authorization)` 호출
  - 예: `services-spring/ticket-service/src/main/java/guru/urr/ticketservice/shared/security/InternalTokenValidator.java`
  - auth-service: `services-spring/auth-service/src/main/java/guru/urr/authservice/security/InternalTokenValidator.java:17-26`
  - timing-safe 비교: `MessageDigest.isEqual()` 사용 (`InternalTokenValidator.java:28-32`)

**RestClient 사용:**

모든 내부 HTTP 호출은 Spring 6의 `RestClient`를 사용하며, 타임아웃 설정이 명시적으로 적용됨:
- connectTimeout: 5초, readTimeout: 10초
- 예: `services-spring/payment-service/src/main/java/guru/urr/paymentservice/client/TicketInternalClient.java:30-31`

**Circuit Breaker (Resilience4j):**

| 설정 | 값 | 출처 |
|------|-----|------|
| sliding-window-size | 10 | `application.yml` (공통) |
| failure-rate-threshold | 50% | 모든 서비스 |
| wait-duration-in-open-state | 10초 | 모든 서비스 |
| permitted-number-of-calls-in-half-open-state | 3 | 모든 서비스 |
| slow-call-duration-threshold | 3초 | 모든 서비스 |
| slow-call-rate-threshold | 80% | 모든 서비스 |

예: `services-spring/catalog-service/src/main/resources/application.yml:57-76`

모든 내부 HTTP 호출에 `@CircuitBreaker` + `@Retry` 어노테이션 적용:
```java
@CircuitBreaker(name = "internalService", fallbackMethod = "validateReservationFallback")
@Retry(name = "internalService")
```
출처: `services-spring/payment-service/src/main/java/guru/urr/paymentservice/client/TicketInternalClient.java:37-38`

Retry 설정: max-attempts 3, wait-duration 500ms, exponential-backoff-multiplier 2.

queue-service에는 Redis 전용 Circuit Breaker(`redisQueue`) 추가 설정 존재:
`services-spring/queue-service/src/main/resources/application.yml:80-86`

### 5-2. 비동기 통신 (Kafka)

**Kafka 토픽 구성:**

`services-spring/ticket-service/src/main/java/guru/urr/ticketservice/shared/config/KafkaConfig.java:16-33`

| 토픽 | 파티션 | 생산자 | 소비자 |
|------|--------|--------|--------|
| `payment-events` | 3 | payment-service | ticket-service (`ticket-service-group`), stats-service (`stats-service-group`) |
| `reservation-events` | 3 | ticket-service | stats-service (`stats-service-group`) |
| `transfer-events` | 3 | ticket-service | stats-service (`stats-service-group`) |
| `membership-events` | 3 | ticket-service | stats-service (`stats-service-group`) |

**생산자 (Producer):**

1. **payment-service** (`PaymentEventProducer`):
   - `PaymentConfirmedEvent` 발행 (`services-spring/payment-service/src/main/java/guru/urr/paymentservice/messaging/PaymentEventProducer.java:22-30`)
   - `PaymentRefundedEvent` 발행 (`PaymentEventProducer.java:32-42`)
   - acks=all, retries=3 (`services-spring/payment-service/src/main/resources/application.yml:9-10`)

2. **ticket-service** (`TicketEventProducer`):
   - `ReservationCreatedEvent` -> `reservation-events` (`TicketEventProducer.java:24-33`)
   - `ReservationConfirmedEvent` -> `reservation-events` (`TicketEventProducer.java:35-44`)
   - `ReservationCancelledEvent` -> `reservation-events` (`TicketEventProducer.java:46-55`)
   - `TransferCompletedEvent` -> `transfer-events` (`TicketEventProducer.java:57-66`)
   - `MembershipActivatedEvent` -> `membership-events` (`TicketEventProducer.java:68-77`)

(파일 경로: `services-spring/ticket-service/src/main/java/guru/urr/ticketservice/messaging/TicketEventProducer.java`)

**소비자 (Consumer):**

1. **ticket-service** `PaymentEventConsumer`:
   - 토픽: `payment-events`, 그룹: `ticket-service-group`
   - 예매 결제 확정, 양도 결제 처리, 멤버십 결제 처리, 환불 처리
   - `services-spring/ticket-service/src/main/java/guru/urr/ticketservice/messaging/PaymentEventConsumer.java:54`

2. **stats-service** `StatsEventConsumer`:
   - `payment-events` (`stats-service-group`) - `StatsEventConsumer.java:25-26`
   - `reservation-events` (`stats-service-group`) - `StatsEventConsumer.java:70`
   - `membership-events` (`stats-service-group`) - `StatsEventConsumer.java:116`
   - `transfer-events` (`stats-service-group`) - `StatsEventConsumer.java:136`

(파일 경로: `services-spring/stats-service/src/main/java/guru/urr/statsservice/messaging/StatsEventConsumer.java`)

**이벤트 스키마/DTO:**

| 이벤트 | 필드 | 출처 |
|--------|------|------|
| `PaymentConfirmedEvent` | type("PAYMENT_CONFIRMED"), paymentId, orderId, userId, reservationId, referenceId, paymentType, amount, paymentMethod, timestamp | `services-spring/payment-service/src/main/java/guru/urr/paymentservice/messaging/event/PaymentConfirmedEvent.java:6-24` |
| `PaymentRefundedEvent` | type("PAYMENT_REFUNDED"), paymentId, orderId, userId, reservationId, referenceId, paymentType, amount, reason, timestamp | `services-spring/payment-service/src/main/java/guru/urr/paymentservice/messaging/event/PaymentRefundedEvent.java:6-25` |
| `ReservationConfirmedEvent` | reservationId, userId, eventId, totalAmount, paymentMethod, timestamp | `services-spring/ticket-service/src/main/java/guru/urr/ticketservice/messaging/event/ReservationConfirmedEvent.java` |
| `ReservationCancelledEvent` | reservationId, userId, eventId, reason, timestamp | `services-spring/ticket-service/src/main/java/guru/urr/ticketservice/messaging/event/ReservationCancelledEvent.java` |
| `TransferCompletedEvent` | transferId, reservationId, sellerId, buyerId, amount, timestamp | `services-spring/ticket-service/src/main/java/guru/urr/ticketservice/messaging/event/TransferCompletedEvent.java` |
| `MembershipActivatedEvent` | membershipId, userId, artistId, timestamp | `services-spring/ticket-service/src/main/java/guru/urr/ticketservice/messaging/event/MembershipActivatedEvent.java` |

**멱등성 처리 (Exactly-Once Semantics 근사):**

Kafka Consumer 쪽에서 애플리케이션 레벨 중복 처리 방지:

1. **ticket-service**: `processed_events` 테이블 (event_key + consumer_group)
   - 이벤트 키 구성: `sagaId` 우선, 없으면 `type:referenceId`
   - `PaymentEventConsumer.java:200-238`
   - 테이블: `V14__processed_events.sql`

2. **stats-service**: `processed_events` 테이블 (event_key)
   - 이벤트 키 구성: `type:id:timestamp`
   - `StatsEventConsumer.java:170-203`
   - 테이블: `V2__processed_events_table.sql`

Producer 설정: `acks: all`, `retries: 3` (at-least-once 보장), `spring.json.add.type.headers: false`
Consumer 설정: `auto-offset-reset: earliest`, `spring.json.use.type.headers: false`, `spring.json.value.default.type: java.util.LinkedHashMap`

### 5-3. Redis 활용

**1. Rate Limiting (gateway-service)**
- Redis Lua 스크립트 기반 슬라이딩 윈도우
- 키 패턴: `rate:{category}:{clientId}` (60초 윈도우)
- Fallback: Redis 장애 시 `ConcurrentHashMap` 인메모리 카운터 사용
- 출처: `services-spring/gateway-service/src/main/java/guru/urr/gatewayservice/filter/RateLimitFilter.java:84-99`

**2. 좌석 잠금 (ticket-service)**
- Redis Lua 스크립트를 통한 분산 좌석 잠금
- 키 패턴: `seat:{eventId}:{seatId}`
- 펜싱 토큰(fencing token): 순차 증가하는 토큰으로 ABA 문제 방지
- 스크립트: `seat_lock_acquire.lua`, `seat_lock_release.lua`, `payment_verify.lua`
- 출처: `services-spring/ticket-service/src/main/java/guru/urr/ticketservice/domain/seat/service/SeatLockService.java:39-112`
- 설정: `services-spring/ticket-service/src/main/java/guru/urr/ticketservice/shared/config/RedisConfig.java:14-35`

**3. 대기열 관리 (queue-service)**
- 대기열: ZSET `{eventId}:queue` (score = timestamp 또는 VWR position)
- 활성 사용자: ZSET `{eventId}:active` (score = 만료 timestamp)
- 하트비트 추적: ZSET `{eventId}:seen`, `{eventId}:active-seen`
- 이벤트별 임계값: STRING `{eventId}:threshold`
- 활성 이벤트 목록: SET `queue:active-events`
- 입장 잠금: STRING `admission:lock:{eventId}` (4초 TTL)
- Hash Tag `{eventId}` 사용으로 Redis Cluster slot affinity 보장
- 출처: `services-spring/queue-service/src/main/java/guru/urr/queueservice/service/QueueService.java:291-307`

**4. Prod 환경 Redis Cluster 설정:**
- gateway-service: `services-spring/gateway-service/src/main/resources/application.yml:128-144`
- queue-service: `services-spring/queue-service/src/main/resources/application.yml:97-114`
- ticket-service: `services-spring/ticket-service/src/main/resources/application.yml:113-124`

---

## 6. VWR(Virtual Waiting Room) 앞단 구조

### 6-1. Lambda + API Gateway + DynamoDB 아키텍처

VWR은 2-Tier 설계로 구현되어 있으며, Tier 1(앞단)은 AWS 서버리스 인프라에서 동작한다.

**VWR DynamoDB 카운터 테이블:**

`VwrAdminController.java:59-68`에서 초기화되는 DynamoDB 아이템 구조:

| 속성 | 타입 | 용도 |
|------|------|------|
| `eventId` | String (PK) | 이벤트 식별자 |
| `nextPosition` | Number | 다음 발급할 대기 번호 (Atomic Counter) |
| `servingCounter` | Number | 현재 입장 허용된 최대 번호 |
| `isActive` | Boolean | VWR 활성화 여부 |
| `updatedAt` | Number | 마지막 업데이트 타임스탬프 |

출처: `services-spring/queue-service/src/main/java/guru/urr/queueservice/controller/VwrAdminController.java:59-68`

### 6-2. Position 할당 로직

Lambda@Edge에서 `nextPosition`에 대해 DynamoDB `ADD` 연산(atomic increment)을 수행하여 대기 번호를 발급한다. queue-service의 `VwrAdminController`가 관리자 API를 제공한다.

- 활성화: `POST /api/admin/vwr/activate/{eventId}` - DynamoDB에 카운터 초기화 (`VwrAdminController.java:49-75`)
- 비활성화: `POST /api/admin/vwr/deactivate/{eventId}` - `isActive = false` 설정 (`VwrAdminController.java:80-104`)

### 6-3. Admission (Serving Counter) 전진

- 수동 전진: `POST /api/admin/vwr/advance/{eventId}` - batchSize만큼 servingCounter 증가 (`VwrAdminController.java:143-184`)
  - `conditionExpression: "attribute_exists(eventId) AND servingCounter < nextPosition"` (Line 164)
  - 기본 batchSize: 500
- 상태 조회: `GET /api/admin/vwr/status/{eventId}` - nextPosition, servingCounter, waiting 계산 (`VwrAdminController.java:109-138`)

### 6-4. 토큰 생성 및 검증

**VWR에서 Tier 2(queue-service)로 전환 시:**

사용자의 VWR position이 servingCounter 이하이면, queue-service의 `check` 엔드포인트에 `vwrPosition` 파라미터로 전달된다 (`QueueController.java:31-37`). queue-service는 이 값을 Redis ZSET의 score로 사용하여 VWR 순서를 유지한다 (`QueueService.java:84`).

**Entry Token 생성:**

queue-service에서 사용자가 active 상태가 되면 JWT 기반 entry token을 발급한다:
```java
Jwts.builder()
    .subject(eventId)
    .claim("uid", userId)
    .issuedAt(issuedAt)
    .expiration(expiration)
    .signWith(entryTokenKey)
    .compact();
```
출처: `services-spring/queue-service/src/main/java/guru/urr/queueservice/service/QueueService.java:228-236`

**Entry Token 검증 (gateway):**

`VwrEntryTokenFilter`가 `/api/seats/**`, `/api/reservations/**` 경로를 보호:
- `x-queue-entry-token` 헤더에서 JWT 파싱 및 서명 검증 (`VwrEntryTokenFilter.java:82-87`)
- VWR token의 `uid` claim과 Auth JWT의 X-User-Id 일치 확인 (`VwrEntryTokenFilter.java:90-98`)
- CloudFront bypass: `X-CloudFront-Verified` 헤더가 cloudfront secret과 일치하면 토큰 검증 생략 (`VwrEntryTokenFilter.java:64-72`)

출처: `services-spring/gateway-service/src/main/java/guru/urr/gatewayservice/filter/VwrEntryTokenFilter.java:60-113`

### 6-5. 서버리스 선택 이유

VWR Tier 1을 서버리스(Lambda@Edge + DynamoDB)로 구현한 이유:

1. **트래픽 급증 대응**: 티켓 판매 오픈 시 수십만 동시 접속이 발생하며, Lambda@Edge는 CDN 엣지에서 자동 스케일링
2. **DynamoDB Atomic Counter**: `nextPosition` 발급에 단일 atomic increment 연산으로 충분하며, 수만 TPS 처리 가능
3. **Pod 기반 대비 비용 효율**: 평소에는 트래픽이 거의 없고 판매 시점에만 급증하는 패턴에 서버리스가 적합
4. **엣지 지연시간**: Lambda@Edge가 사용자에게 가장 가까운 지점에서 대기 번호를 발급하여 지연시간 최소화

---

## 7. 뒷단 대기열 (Queue Service) 구현

### 7-1. Redis 데이터 구조

| 키 패턴 | 타입 | 용도 | 출처 |
|---------|------|------|------|
| `{eventId}:queue` | ZSET | 대기열 (score=timestamp/VWR position) | `QueueService.java:293-295` |
| `{eventId}:active` | ZSET | 활성 사용자 (score=만료 timestamp) | `QueueService.java:297-299` |
| `{eventId}:seen` | ZSET | 대기열 사용자 하트비트 | `QueueService.java:301-303` |
| `{eventId}:active-seen` | ZSET | 활성 사용자 하트비트 | `QueueService.java:305-307` |
| `{eventId}:threshold` | STRING | 이벤트별 동시 접속 한도 | `QueueService.java:283-285` |
| `queue:active-events` | SET | 활성 이벤트 목록 | `QueueService.java:274-278` |
| `admission:lock:{eventId}` | STRING | 입장 처리 분산 잠금 (4초 TTL) | `AdmissionWorkerService.java:69-70` |

### 7-2. Admission Batch 처리

`AdmissionWorkerService`가 `@Scheduled`로 주기적으로 대기열에서 활성 사용자로 이동:

- 실행 주기: 1초 (`queue.admission.interval-ms:1000`) (`AdmissionWorkerService.java:47`)
- 배치 크기: 100 (`queue.admission.batch-size:100`) (`AdmissionWorkerService.java:36`)
- Redis Lua 스크립트(`admissionScript`)로 원자적 이동 실행 (`AdmissionWorkerService.java:80-91`)
- 분산 잠금: `setIfAbsent`로 이벤트별 잠금 획득 후 처리 (`AdmissionWorkerService.java:69`)
- 활성 이벤트 자동 정리: 대기열과 활성 사용자가 모두 비면 `queue:active-events`에서 제거 (`AdmissionWorkerService.java:101-107`)

출처: `services-spring/queue-service/src/main/java/guru/urr/queueservice/service/AdmissionWorkerService.java:47-119`

### 7-3. Queue Position 폴링

사용자는 `GET /api/queue/status/{eventId}`로 상태를 폴링하며, 응답에 다음 폴링 간격이 포함됨:

| 대기 순위 | 폴링 간격(초) | 출처 |
|----------|-------------|------|
| 1~1000 | 1 | `QueueService.java:242` |
| 1001~5000 | 5 | `QueueService.java:243` |
| 5001~10000 | 10 | `QueueService.java:244` |
| 10001~100000 | 30 | `QueueService.java:245` |
| 100001~ | 60 | `QueueService.java:246` |

### 7-4. Stale User Cleanup

`AdmissionWorkerService.cleanupStaleUsers()`:
- 실행 주기: 30초 (`queue.stale-cleanup.interval-ms:30000`) (`AdmissionWorkerService.java:122`)
- 대기열: `seen` ZSET에서 하트비트 없는 사용자를 `queue` ZSET에서 제거
- 활성 사용자: `active-seen` ZSET에서 만료된 항목 제거
- 배치 처리: 1000명씩 반복, 100ms sleep (`AdmissionWorkerService.java:142-168`)

출처: `services-spring/queue-service/src/main/java/guru/urr/queueservice/service/AdmissionWorkerService.java:122-185`

### 7-5. SQS 연동

`SqsPublisher`가 사용자 입장 시 SQS FIFO 큐에 메시지 발행:
- Message Group ID: `eventId` (이벤트 단위 순서 보장)
- Deduplication ID: `userId:eventId` (5분 중복 방지 윈도우)
- 장애 시 Redis-only fallback (fire-and-forget)
- 활성화 조건: `aws.sqs.enabled: true` + `SqsClient` + `queueUrl` 모두 설정 시

출처: `services-spring/queue-service/src/main/java/guru/urr/queueservice/service/SqsPublisher.java:38-68`

### 7-6. Two-Tier 설계 근거

| | Tier 1 (VWR) | Tier 2 (Queue Service) |
|---|---|---|
| 인프라 | Lambda@Edge + DynamoDB | Spring Boot + Redis |
| 역할 | 대기 번호 발급, 1차 필터링 | 세부 대기열 관리, 입장 토큰 발급 |
| 확장성 | CDN 엣지에서 무한 스케일 | Redis Cluster + Pod 수평 확장 |
| 데이터 | DynamoDB atomic counter | Redis ZSET (정밀 순서) |

Tier 1에서 대량 트래픽을 흡수하고, serving counter까지 도달한 사용자만 Tier 2로 유입되어 실제 서비스 부하를 제어한다.

---

## 8. 동시성 처리

### 8-1. 낙관적 잠금 (@Version 패턴)

seats 테이블에 `version` 컬럼을 사용한 수동 낙관적 잠금:

```sql
-- V8__seats_concurrency_columns.sql:2
ALTER TABLE seats ADD COLUMN IF NOT EXISTS version INTEGER NOT NULL DEFAULT 0;
```

예매 시 version 체크 후 업데이트:
```java
int updated = jdbcTemplate.update("""
    UPDATE seats
    SET status = 'locked', version = version + 1,
        fencing_token = ?, locked_by = CAST(? AS UUID), updated_at = NOW()
    WHERE id = ? AND version = ?
    """, fencingToken, userId, seat.get("id"), currentVersion);

if (updated == 0) {
    throw new ResponseStatusException(HttpStatus.CONFLICT, "Seat modified concurrently");
}
```
출처: `services-spring/ticket-service/src/main/java/guru/urr/ticketservice/domain/reservation/service/ReservationService.java:122-133`

### 8-2. 비관적 잠금 (`FOR UPDATE`)

다중 서비스에서 `SELECT ... FOR UPDATE`를 사용:

| 서비스 | 사용 위치 | 출처 |
|--------|----------|------|
| ticket-service | 좌석 예매 시 좌석 행 잠금 | `ReservationService.java:92-99` |
| ticket-service | 예매 취소 시 예매 행 잠금 | `ReservationService.java:485` |
| ticket-service | 만료 예매 정리 시 `FOR UPDATE SKIP LOCKED` | `ReservationCleanupScheduler.java:44` |
| payment-service | 결제 확인 시 결제 행 잠금 | `PaymentService.java:122-127` |
| payment-service | 결제 취소 시 결제 행 잠금 | `PaymentService.java:196-201` |

`FOR UPDATE SKIP LOCKED`는 ReservationCleanupScheduler에서 사용되어, 다른 트랜잭션에 의해 잠긴 행을 건너뛰고 처리한다 (`ReservationCleanupScheduler.java:44`).

### 8-3. Redis 분산 잠금

**좌석 잠금 (SeatLockService):**

Redis Lua 스크립트를 통한 원자적 좌석 잠금:
- **acquire**: `seat_lock_acquire.lua` - 좌석 키 설정 + 펜싱 토큰 발급 + TTL 설정
- **release**: `seat_lock_release.lua` - 소유자 확인 + 펜싱 토큰 검증 후 삭제
- **verify**: `payment_verify.lua` - 결제 시 소유자 + 펜싱 토큰 검증

출처: `services-spring/ticket-service/src/main/java/guru/urr/ticketservice/domain/seat/service/SeatLockService.java:39-99`
설정: `services-spring/ticket-service/src/main/java/guru/urr/ticketservice/shared/config/RedisConfig.java:14-35`

**대기열 입장 잠금 (AdmissionWorkerService):**

`setIfAbsent` 기반 간단한 분산 잠금:
```java
acquired = redisTemplate.opsForValue().setIfAbsent(lockKey, "1", Duration.ofSeconds(4));
```
출처: `services-spring/queue-service/src/main/java/guru/urr/queueservice/service/AdmissionWorkerService.java:69-70`

### 8-4. 데이터베이스 수준 잠금

- `UNIQUE` 제약조건을 통한 중복 방지:
  - `reservations.idempotency_key` (`V12__reservation_idempotency.sql:4-5`)
  - `payments.order_id`, `payments.payment_key` (`V1__payment_schema.sql:8-9`)
  - `artist_memberships(user_id, artist_id)` (`V4__membership_tables.sql:14`)
  - `processed_events.event_key` (`V14__processed_events.sql:2`)

### 8-5. 좌석 예매 경합 조건 처리

좌석 예매는 3단계(Phase) 잠금 프로토콜을 사용한다:

1. **Phase 1 - Redis Lua 좌석 잠금**: `seatLockService.acquireLock()` 호출, 펜싱 토큰 발급 (`ReservationService.java:76-89`)
2. **Phase 2 - DB 비관적 잠금**: `SELECT ... FOR UPDATE`로 좌석 행 잠금, 상태 확인 (`ReservationService.java:92-114`)
3. **Phase 3 - 낙관적 잠금 업데이트**: `WHERE version = ?`로 동시 수정 감지 (`ReservationService.java:117-133`)

잠금 획득 실패 또는 버전 불일치 시 이미 획득한 Redis 잠금을 롤백:
```java
releaseLocks(request.eventId(), request.seatIds(), userId, lockResults);
```
출처: `services-spring/ticket-service/src/main/java/guru/urr/ticketservice/domain/reservation/service/ReservationService.java:169-174`

결제 확정 시 펜싱 토큰 재검증:
```java
if (token > 0 && !seatLockService.verifyForPayment(eventId, seatId, userId, token)) {
    throw new ResponseStatusException(HttpStatus.CONFLICT, "Seat lock expired or stolen.");
}
```
출처: `services-spring/ticket-service/src/main/java/guru/urr/ticketservice/domain/reservation/service/ReservationService.java:413`

### 8-6. 결제 멱등성

1. **예매 멱등성**: `idempotency_key` 컬럼으로 중복 예매 방지 (`ReservationService.java:62-69`, `ReservationService.java:183-190`)
2. **결제 멱등성**: 기존 confirmed 결제 존재 시 즉시 반환 (`PaymentService.java:97-106`, `PaymentService.java:294-311`)
3. **Kafka 소비 멱등성**: `processed_events` 테이블로 이벤트 중복 처리 방지 (`PaymentEventConsumer.java:62-65`, `StatsEventConsumer.java:29-30`)
4. **DuplicateKeyException 무시**: `markProcessed()`에서 동시 소비자 간 중복 삽입 허용 (`PaymentEventConsumer.java:234`)

---

## 9. 인증/인가 (JWT)

### 9-1. JWT 토큰 구조

**Access Token Claims:**
```json
{
  "sub": "userId",
  "userId": "UUID",
  "email": "user@example.com",
  "role": "user|admin",
  "type": "access",
  "iat": 1234567890,
  "exp": 1234569690
}
```
출처: `services-spring/auth-service/src/main/java/guru/urr/authservice/security/JwtService.java:36-46`

**Refresh Token Claims:**
```json
{
  "sub": "userId",
  "userId": "UUID",
  "type": "refresh",
  "familyId": "UUID",
  "jti": "UUID (unique per token)",
  "iat": 1234567890,
  "exp": 1235172690
}
```
출처: `services-spring/auth-service/src/main/java/guru/urr/authservice/security/JwtService.java:52-67`

**만료 시간:**
- Access Token: 1800초 (30분) - `application.yml:57`
- Refresh Token: 604800초 (7일) - `application.yml:58`

### 9-2. 토큰 생성 (auth-service)

`JwtService.generateToken()`:
- HMAC-SHA 키: `JWT_SECRET` 환경변수 (Base64 또는 raw bytes, 최소 32바이트)
- 서명: `Keys.hmacShaKeyFor(keyBytes)` + `signWith(signingKey())`
- 출처: `services-spring/auth-service/src/main/java/guru/urr/authservice/security/JwtService.java:31-46`

Refresh Token Rotation:
- family_id로 토큰 가족 추적
- 사용된 토큰은 revoked_at 설정
- 이미 revoked된 토큰 재사용 시 해당 family 전체 폐기 (토큰 탈취 대응)
- 출처: `services-spring/auth-service/src/main/java/guru/urr/authservice/service/AuthService.java:127-141`

### 9-3. 토큰 검증 (gateway-service)

`JwtAuthFilter` (Order -1):
1. 외부에서 유입된 `X-User-Id`, `X-User-Email`, `X-User-Role` 헤더를 제거 (스푸핑 방지) (`JwtAuthFilter.java:54`)
2. `Authorization: Bearer {token}` 헤더에서 JWT 추출 (`JwtAuthFilter.java:57`)
3. jjwt 라이브러리로 서명 검증 및 claims 추출 (`JwtAuthFilter.java:60-64`)
4. 검증 성공 시 `X-User-Id`, `X-User-Email`, `X-User-Role` 헤더를 다운스트림 요청에 주입 (`JwtAuthFilter.java:71-76`)
5. 검증 실패 시 헤더 없이 통과 (인증 불필요 엔드포인트 대응) (`JwtAuthFilter.java:84-85`)

출처: `services-spring/gateway-service/src/main/java/guru/urr/gatewayservice/filter/JwtAuthFilter.java:50-86`

### 9-4. Refresh Token 플로우

1. 클라이언트가 `POST /api/auth/refresh` 호출
2. `refresh_token` 쿠키 또는 요청 body에서 토큰 추출 (`AuthController.java:69-78`)
3. JWT 서명 검증 + `type: "refresh"` 확인 (`AuthService.java:116-120`)
4. DB에서 토큰 해시 조회, 재사용 여부 확인 (`AuthService.java:128-141`)
5. 현재 토큰 revoke, 새 access + refresh token 발급 (`AuthService.java:144-152`)
6. 새 토큰을 쿠키에 설정 (`AuthController.java:80-82`)

### 9-5. Google OAuth 연동

1. 프론트엔드에서 Google Sign-In으로 `credential` (ID Token) 획득
2. `POST /api/auth/google`으로 전송 (`AuthController.java:85-101`)
3. `GoogleIdTokenVerifier`로 ID Token 검증 (`AuthService.java:206-211`)
4. Google ID로 기존 사용자 조회, 없으면 자동 회원가입 (`AuthService.java:227-238`)
5. JWT access + refresh token 발급 (`AuthService.java:240-243`)

출처: `services-spring/auth-service/src/main/java/guru/urr/authservice/service/AuthService.java:197-259`

### 9-6. Internal API Token (서비스 간 통신)

- 모든 서비스가 `INTERNAL_API_TOKEN` 환경변수를 공유
- 호출 측: `Authorization: Bearer {INTERNAL_API_TOKEN}` 또는 `x-internal-token` 헤더
- 검증: `MessageDigest.isEqual()` 타이밍-세이프 비교
- 출처: `services-spring/auth-service/src/main/java/guru/urr/authservice/security/InternalTokenValidator.java:17-32`

### 9-7. Cookie 설정

`CookieHelper` (`services-spring/auth-service/src/main/java/guru/urr/authservice/util/CookieHelper.java:9-65`):

| 쿠키 | 속성 | 출처 |
|------|------|------|
| `access_token` | httpOnly=true, secure=configurable, path="/", SameSite=Lax, maxAge=1800초 | `CookieHelper.java:28-36` |
| `refresh_token` | httpOnly=true, secure=configurable, path="/api/auth", SameSite=Lax, maxAge=604800초 | `CookieHelper.java:38-46` |

`refresh_token` 쿠키의 path가 `/api/auth`로 제한되어 있어, 다른 API 호출 시 refresh token이 불필요하게 전송되지 않는다.

Gateway의 `CookieAuthFilter`(Order -2)가 `access_token` 쿠키를 `Authorization` 헤더로 변환:
`services-spring/gateway-service/src/main/java/guru/urr/gatewayservice/filter/CookieAuthFilter.java:24-41`

---

## 10. 평가

### 10-1. 잘된 점

1. **3단계 좌석 잠금 프로토콜**: Redis Lua(분산 잠금) -> DB FOR UPDATE(비관적) -> version 체크(낙관적)의 조합으로 좌석 경합 조건을 견고하게 처리한다. 펜싱 토큰을 통해 ABA 문제도 방지한다.
   - `ReservationService.java:74-133`

2. **Refresh Token Rotation + Family-based Revocation**: 토큰 재사용 탐지 시 family 전체를 폐기하는 구현은 보안 모범 사례를 충실히 따르고 있다.
   - `AuthService.java:127-141`

3. **Gateway에서의 JWT 검증 + 헤더 주입**: 각 다운스트림 서비스가 JWT_SECRET을 알 필요 없이 X-User-* 헤더만으로 사용자 정보를 얻는 구조가 깔끔하다. 외부 X-User-* 헤더 스푸핑도 방지한다.
   - `JwtAuthFilter.java:50-86`

4. **Kafka 소비자 멱등성**: `processed_events` 테이블을 통한 애플리케이션 레벨 중복 처리 방지가 ticket-service와 stats-service 모두에 구현되어 있다.
   - `PaymentEventConsumer.java:200-238`, `StatsEventConsumer.java:170-203`

5. **2-Tier 대기열 아키텍처**: VWR(Lambda@Edge + DynamoDB)로 트래픽 급증을 흡수하고, queue-service(Redis)로 세밀한 대기열 관리를 수행하는 설계가 실용적이다.

6. **동기+비동기 이중 확인 패턴**: payment-service가 내부 API로 동기 확인 후 Kafka로 비동기 이벤트도 발행하여, 동기 실패 시 Kafka가 최종 일관성을 보장한다.
   - `PaymentService.java:354-376`

7. **Reconciliation Scheduler**: Kafka 장애 시 payment-reservation 상태 불일치를 5분 주기로 자동 복구한다.
   - `PaymentReconciliationScheduler.java:47-104`

8. **Circuit Breaker + Retry + Fallback**: 모든 내부 HTTP 호출에 Resilience4j가 적용되어 서비스 장애 전파를 방지한다.

9. **Rate Limiting 카테고리화**: AUTH, QUEUE, BOOKING, GENERAL 4가지 카테고리로 세분화하고, Redis 장애 시 인메모리 fallback을 제공한다.
   - `RateLimitFilter.java:130-153`

10. **Flyway 마이그레이션**: 모든 서비스가 Flyway를 사용하여 스키마 버전 관리가 체계적이다.

### 10-2. 미흡한 점

1. **JPA와 JdbcTemplate 혼용의 비일관성**: auth-service, payment-service, stats-service는 JPA Entity를 정의하지만, ticket-service의 핵심 도메인(좌석, 예매 등)은 JdbcTemplate으로 원시 SQL을 직접 실행한다. 이로 인해 타입 안전성이 떨어지고, 도메인 모델이 코드에 명시적으로 표현되지 않는다.
   - 예: `ReservationService.java` 전체가 `Map<String, Object>` 기반

2. **catalog-service와 ticket-service 간 데이터 중복**: 두 서비스가 유사한 테이블(events, ticket_types, seat_layouts)을 각각 독립 DB에 소유하고 있어, 데이터 동기화 메커니즘이 명시적으로 보이지 않는다. catalog-service가 ticket-service의 내부 API를 호출하여 데이터를 가져오지만, 일관성 보장 전략이 불명확하다.

3. **Kafka Producer 설정에 exactly-once 미적용**: `acks: all`과 `retries: 3`으로 at-least-once는 보장하지만, `enable.idempotence: true`나 트랜잭셔널 Producer 설정이 없다. 소비자 측 `processed_events` 테이블로 보완하고 있으나, Producer 레벨에서의 중복 방지가 부족하다.
   - `services-spring/payment-service/src/main/resources/application.yml:6-12`

4. **API 응답 타입의 비정형성**: 대부분의 엔드포인트가 `Map<String, Object>`를 반환하여, API 계약(contract)이 코드에서 명확하지 않다. OpenAPI/Swagger 문서 자동 생성이 어렵고, 클라이언트 타입 안전성이 부재하다.

5. **분산 트랜잭션 부재**: payment-service와 ticket-service 간에 Saga 패턴의 명시적 구현이 없다. Kafka 이벤트 + Reconciliation으로 최종 일관성을 추구하지만, 보상 트랜잭션(compensating transaction) 흐름이 체계적으로 정의되어 있지 않다.

6. **VWR DynamoDB -> queue-service 데이터 흐름**: VWR에서 발급된 position이 queue-service의 Redis에 어떻게 전달되는지 명시적 코드가 부족하다. 프론트엔드가 `vwrPosition` 파라미터를 수동으로 전달하는 구조로 보이며, 이는 클라이언트 조작에 취약할 수 있다.

7. **테스트 커버리지**: 일부 서비스(특히 queue-service, community-service)의 테스트가 제한적이다. 동시성 처리 관련 통합 테스트가 부족하다.

8. **Internal API Token 단일 공유 시크릿**: 모든 서비스가 동일한 `INTERNAL_API_TOKEN`을 공유하여, 한 서비스가 침해되면 모든 내부 API에 접근 가능하다. 서비스별 토큰 분리나 mTLS 미적용.

### 10-3. AWS 배포 시 보완 가능한 점

1. **Amazon MSK(Managed Kafka)**: 현재 단일 브로커 설정(`replication-factor: 1`)을 MSK로 전환하여 3-브로커 클러스터 + `min.insync.replicas: 2` 설정으로 데이터 내구성 강화. Producer에 `enable.idempotence: true` 추가.

2. **Amazon ElastiCache Redis Cluster**: 현재 prod 프로파일에 Redis Cluster 설정이 이미 존재하지만(`application.yml` prod 섹션), AWS ElastiCache의 자동 failover, 백업, 모니터링을 활용할 수 있다.

3. **AWS ALB + WAF**: gateway-service 앞단에 ALB를 배치하고, WAF로 DDoS/Bot 방어를 추가. 현재 gateway의 Rate Limiting은 애플리케이션 레벨이므로, 네트워크 레벨 보호가 필요하다.

4. **AWS Secrets Manager**: 현재 환경변수(`JWT_SECRET`, `INTERNAL_API_TOKEN`, DB 비밀번호)로 관리되는 시크릿을 Secrets Manager로 통합 관리하고, 자동 로테이션을 적용.

5. **Amazon RDS Multi-AZ + Read Replica**: Database-per-Service 패턴의 각 DB를 RDS Multi-AZ로 배포하여 가용성 확보. stats-service, catalog-service 같은 읽기 중심 서비스는 Read Replica 활용.

6. **AWS X-Ray/CloudWatch**: 현재 Zipkin 기반 분산 추적이 구현되어 있으나, AWS 배포 시 X-Ray로 전환하거나 ADOT(AWS Distro for OpenTelemetry)로 통합하여 CloudWatch와 네이티브 연동.

7. **Service Mesh (App Mesh / Istio)**: 현재 `INTERNAL_API_TOKEN` 기반 서비스 간 인증을 mTLS로 대체하여 보안 강화. 서비스별 세분화된 접근 제어(RBAC) 적용 가능.

8. **SQS FIFO + DLQ**: queue-service의 SQS 연동에 Dead Letter Queue를 추가하여 실패 메시지 재처리 전략 수립. 현재는 실패 시 Redis-only fallback이지만, DLQ를 통한 체계적 실패 처리가 필요하다.

9. **CloudFront + Lambda@Edge 완성**: VWR Tier 1의 Lambda@Edge 코드가 별도 디렉토리에 존재할 것으로 예상되나, 현재 `services-spring/` 범위에서는 Admin API만 확인된다. CloudFront 배포와 Lambda@Edge 함수의 완전한 구현 및 CI/CD 파이프라인 통합이 필요하다.

10. **Prometheus + Grafana -> Amazon Managed Prometheus/Grafana**: 모든 서비스에 Prometheus 메트릭이 이미 노출되어 있으므로(`/actuator/prometheus`), AMP/AMG로 전환하여 운영 부담 감소. 커스텀 비즈니스 메트릭(`BusinessMetrics`, `QueueMetrics`)도 이미 구현되어 있어 대시보드 구성이 즉시 가능하다.
