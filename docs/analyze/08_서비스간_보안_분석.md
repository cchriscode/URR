# URR 서비스 간 보안 분석 — mTLS 부재와 현재 보호 전략

> 분석 대상: 서비스 간 인증/암호화 구조
> 분석 일자: 2026-02-17

---

## 1. 결론 요약

**URR은 mTLS를 사용하지 않는다.** 서비스 간 통신은 클러스터 내부 평문 HTTP이며, 3가지 보호 레이어로 보안을 확보한다.

| 보호 레이어 | 방식 | 역할 |
|-------------|------|------|
| L3/L4 네트워크 격리 | K8s NetworkPolicy (default-deny + 허용 목록) | 허가된 Pod만 통신 가능 |
| L7 토큰 인증 | `INTERNAL_API_TOKEN` (timing-safe 비교) | `/internal/*` 엔드포인트 접근 제어 |
| 서비스 노출 제한 | ClusterIP (클러스터 외부 접근 차단) | 외부에서 직접 서비스 호출 불가 |

---

## 2. 현재 통신 구조

### 2.1 트래픽 흐름

```
[외부 트래픽]
인터넷 → CloudFront (TLS) → ALB (TLS) → Gateway Pod (평문 HTTP)
                                              ↓
[클러스터 내부 — 전부 평문 HTTP]
Gateway ──HTTP──→ auth-service:3005
Gateway ──HTTP──→ ticket-service:3002
Gateway ──HTTP──→ payment-service:3003
Gateway ──HTTP──→ catalog-service:3009
Gateway ──HTTP──→ queue-service:3007
Gateway ──HTTP──→ stats-service:3004
Gateway ──HTTP──→ community-service:3008

payment-service ──HTTP──→ ticket-service:3002/internal/*
ticket-service  ──HTTP──→ payment-service:3003/internal/*
catalog-service ──HTTP──→ auth-service:3005/internal/*
queue-service   ──HTTP──→ catalog-service:3009/internal/*

[데이터 레이어 — TLS 사용]
서비스 ──TLS──→ RDS PostgreSQL (5432)       ← AWS 관리형 TLS
서비스 ──TLS──→ ElastiCache Redis (6379)    ← transit_encryption_enabled
서비스 ──TLS──→ MSK Kafka (9094)            ← client_broker = "TLS"
```

**핵심**: 외부→클러스터 구간과 서비스→데이터 레이어 구간은 TLS 암호화되지만, **서비스 간 통신(Pod↔Pod)은 평문 HTTP**이다.

### 2.2 외부 통신 TLS 현황

| 구간 | 암호화 | 출처 |
|------|--------|------|
| Client → CloudFront | TLS 1.3 | `terraform/modules/cloudfront/main.tf` (ACM 인증서) |
| CloudFront → ALB | HTTPS | `cloudfront/main.tf:91-106` (HTTPS only origin) |
| ALB → EKS Pod | **평문 HTTP** | `alb/main.tf:119-150` (HTTP target group) |
| Pod → RDS | TLS | `rds/main.tf:59` (storage_encrypted) |
| Pod → Redis | **TLS** | `elasticache/main.tf:113` (transit_encryption_enabled) |
| Pod → Kafka | **TLS** | `msk/main.tf:163` (client_broker = "TLS") |
| Pod ↔ Pod | **평문 HTTP** | ClusterIP 서비스, 암호화 없음 |

Redis TLS 설정 확인:
- Terraform: `terraform/modules/elasticache/main.tf:113` — `transit_encryption_enabled = true`
- Spring Boot: `ticket-service/application.yml:123-124` — `ssl.enabled: true` (prod 프로필)

---

## 3. 보호 레이어 1: NetworkPolicy (L3/L4 격리)

### 3.1 Default Deny

모든 Pod 간 통신을 기본 차단한 후, 필요한 경로만 허용하는 화이트리스트 방식이다.

**출처**: `k8s/spring/base/network-policies.yaml:1-9`

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: default-deny-all
spec:
  podSelector: {}         # 모든 Pod에 적용
  policyTypes:
    - Ingress             # 들어오는 트래픽 전부 차단
    - Egress              # 나가는 트래픽 전부 차단
```

### 3.2 Ingress 허용 규칙 (누가 누구에게 접근 가능한가)

**출처**: `k8s/spring/base/network-policies.yaml:11-177`

| 대상 서비스 | 허용된 호출자 | 포트 | 라인 |
|-------------|-------------|------|------|
| gateway-service | **모든 Pod** (ALB 트래픽 수신) | 3001 | 11-23 |
| frontend | **모든 Pod** (ALB 트래픽 수신) | 3000 | 24-37 |
| auth-service | gateway, catalog | 3005 | 39-59 |
| ticket-service | gateway, payment, catalog | 3002 | 61-83 |
| catalog-service | gateway, queue | 3009 | 85-104 |
| payment-service | gateway만 | 3003 | 106-122 |
| stats-service | gateway만 | 3004 | 124-140 |
| queue-service | gateway만 | 3007 | 142-158 |
| community-service | gateway만 | 3008 | 160-176 |

**시각화:**

```
                        ┌──────────────────────────────────────┐
                        │         K8s 클러스터 내부              │
                        │                                      │
  ALB ──→ gateway-service ──→ auth-service                     │
          (누구나 접근)  │ ──→ ticket-service ←── payment-service│
                        │ ──→ catalog-service ←── queue-service │
                        │ ──→ payment-service                  │
                        │ ──→ stats-service                    │
                        │ ──→ queue-service                    │
                        │ ──→ community-service                │
                        │                                      │
                        │  ※ 위 화살표 외의 통신은 전부 차단     │
                        └──────────────────────────────────────┘
```

### 3.3 Egress 허용 규칙 (누가 어디로 나갈 수 있는가)

**출처**: `k8s/spring/base/network-policies.yaml:178-375`

| 서비스 | 허용된 목적지 | 라인 |
|--------|-------------|------|
| auth-service | DNS(53)만 | 179-197 |
| ticket-service | payment-service, data tier, DNS | 198-223 |
| payment-service | ticket-service, data tier, DNS | 225-250 |
| queue-service | catalog-service, data tier, DNS | 252-277 |
| stats-service | data tier, DNS | 279-300 |
| catalog-service | auth-service, data tier, DNS | 302-327 |
| community-service | data tier, DNS | 329-350 |
| gateway-service | `tier: backend` 전체, kube-dns | 352-375 |

### 3.4 Prod 추가 Egress (외부 데이터 레이어)

**출처**: `k8s/spring/overlays/prod/network-policy-egress.yaml:1-34`

Prod 환경에서는 AWS 관리형 서비스(RDS, ElastiCache, MSK)가 VPC 내부 서브넷에 있으므로, IP CIDR 기반으로 egress를 허용한다.

```yaml
egress:
  - to:
      - ipBlock:
          cidr: 10.0.20.0/23  # DB 서브넷 → PostgreSQL
    ports:
      - port: 5432
  - to:
      - ipBlock:
          cidr: 10.0.30.0/23  # Cache 서브넷 → Redis
    ports:
      - port: 6379
  - to:
      - ipBlock:
          cidr: 10.0.40.0/23  # Streaming 서브넷 → Kafka
    ports:
      - port: 9092
      - port: 9094
```

---

## 4. 보호 레이어 2: INTERNAL_API_TOKEN (L7 인증)

### 4.1 개요

서비스 간 `/internal/*` API 호출 시, 모든 서비스가 동일한 공유 토큰(`INTERNAL_API_TOKEN`)을 사용하여 인증한다.

**토큰 저장 위치:**
- Kind: `k8s/spring/overlays/kind/secrets.env:31` — `INTERNAL_API_TOKEN=dev-internal-token-change-me`
- Staging: `k8s/spring/overlays/staging/secrets.env.example:14` — `INTERNAL_API_TOKEN=<change-me>`
- Prod: `k8s/spring/overlays/prod/secrets.env.example:12` — `INTERNAL_API_TOKEN=<strong-random-token>`

모든 서비스가 동일한 K8s Secret에서 같은 토큰을 주입받는다.

### 4.2 토큰 검증 구현

4개 서비스에 동일한 `InternalTokenValidator` 패턴이 적용되어 있다.

**출처**: `auth-service/src/main/java/guru/urr/authservice/security/InternalTokenValidator.java:1-33`

```java
@Component
public class InternalTokenValidator {

    private final String internalToken;

    public InternalTokenValidator(@Value("${INTERNAL_API_TOKEN}") String internalToken) {
        this.internalToken = internalToken;
    }

    public boolean isValid(String authorization, String xInternalToken) {
        // 1순위: x-internal-token 헤더
        if (xInternalToken != null && !xInternalToken.isBlank()) {
            return timingSafeEquals(internalToken, xInternalToken);
        }
        // 2순위: Authorization: Bearer 헤더
        if (authorization == null || !authorization.startsWith("Bearer ")) {
            return false;
        }
        String token = authorization.substring(7);
        return timingSafeEquals(internalToken, token);
    }

    // Timing-safe 비교 (타이밍 공격 방지)
    private static boolean timingSafeEquals(String a, String b) {
        return MessageDigest.isEqual(
                a.getBytes(StandardCharsets.UTF_8),
                b.getBytes(StandardCharsets.UTF_8));
    }
}
```

**핵심 보안 포인트:**
- `MessageDigest.isEqual()` 사용 → **타이밍 공격 방지** (문자열 비교 시간이 일정)
- 두 가지 헤더 지원: `x-internal-token` (직접) 또는 `Authorization: Bearer` (표준)

### 4.3 필터 적용 (Internal API 보호)

**출처**: `auth-service/src/main/java/guru/urr/authservice/security/InternalApiAuthFilter.java:1-53`

```java
@Component
public class InternalApiAuthFilter extends OncePerRequestFilter {

    @Override
    protected void doFilterInternal(HttpServletRequest request, ...) {
        String token = request.getHeader("x-internal-token");
        if (token == null || token.isBlank()) {
            // Authorization: Bearer 폴백
            String authHeader = request.getHeader("Authorization");
            if (authHeader != null && authHeader.startsWith("Bearer ")) {
                token = authHeader.substring(7);
            }
        }

        // Timing-safe 비교 실패 시 403 Forbidden
        if (token == null || !MessageDigest.isEqual(...)) {
            response.setStatus(403);
            response.getWriter().write("{\"error\":\"Forbidden\"}");
            return;
        }

        filterChain.doFilter(request, response);
    }

    @Override
    protected boolean shouldNotFilter(HttpServletRequest request) {
        return !request.getRequestURI().startsWith("/internal/");  // /internal/* 경로만 필터링
    }
}
```

### 4.4 적용 서비스 및 내부 API 목록

| 서비스 | InternalTokenValidator 파일 | 보호되는 엔드포인트 |
|--------|---------------------------|-------------------|
| auth-service | `authservice/security/InternalTokenValidator.java` | `GET /internal/users/{id}`, `POST /internal/users/batch` |
| ticket-service | `ticketservice/shared/security/InternalTokenValidator.java` | `GET /internal/reservations/{id}/validate`, `POST /internal/reservations/{id}/confirm`, `GET /internal/transfers/{id}/validate`, `POST /internal/transfers/{id}/complete`, `GET /internal/memberships/{id}/validate`, `POST /internal/memberships/{id}/activate` |
| payment-service | `paymentservice/security/InternalTokenValidator.java` | `POST /internal/payments/...` |
| catalog-service | `catalogservice/shared/security/InternalTokenValidator.java` | `GET /internal/events/...` |

### 4.5 호출 측 구현 예시

**출처**: `payment-service/src/main/java/guru/urr/paymentservice/client/TicketInternalClient.java`

```java
// Payment → Ticket 내부 호출 시 토큰 첨부
HttpHeaders headers = new HttpHeaders();
headers.set("Authorization", "Bearer " + internalApiToken);

restTemplate.exchange(
    ticketServiceUrl + "/internal/reservations/" + id + "/validate?userId=" + userId,
    HttpMethod.GET,
    new HttpEntity<>(headers),
    Map.class
);
```

---

## 5. 보호 레이어 3: ClusterIP 서비스 타입

### 5.1 구조

모든 백엔드 서비스는 `ClusterIP` 타입으로 배포되어 클러스터 외부에서 직접 접근이 불가능하다.

**출처**: `k8s/spring/base/gateway-service/service.yaml:1-13`

```yaml
apiVersion: v1
kind: Service
metadata:
  name: gateway-service
spec:
  type: ClusterIP          # 클러스터 내부에서만 접근 가능
  selector:
    app: gateway-service
  ports:
    - port: 3001
      targetPort: 3001
```

외부 트래픽은 반드시 **ALB → Gateway Service → 내부 서비스** 경로를 거쳐야 한다. 개별 서비스(auth, ticket 등)에 직접 접근하는 것은 물리적으로 불가능하다.

---

## 6. mTLS와의 비교

### 6.1 기능별 비교

| 보안 기능 | mTLS (Istio) | URR 현재 (NetworkPolicy + Token) |
|-----------|-------------|----------------------------------|
| **통신 암호화** | 자동 TLS (Pod↔Pod) | 없음 (클러스터 내부 평문 HTTP) |
| **상호 인증** | 인증서 기반 (서비스별 고유 ID) | 공유 토큰 1개 (전 서비스 동일) |
| **인증서 관리** | 자동 발급/갱신/교체 (istiod) | 불필요 (토큰 기반) |
| **접근 제어 세분화** | AuthorizationPolicy (서비스×경로) | NetworkPolicy (Pod×포트) + 코드 검증 |
| **토큰 탈취 위험** | 없음 (인증서는 Pod에 바인딩) | 토큰 유출 시 모든 내부 API 접근 가능 |
| **네트워크 스니핑** | 불가 (TLS 암호화) | 가능 (클러스터 내부 평문) |
| **운영 복잡도** | 높음 (istiod + sidecar) | 낮음 (YAML + Java 코드) |
| **리소스 비용** | Pod당 Envoy sidecar (~50MB) | 없음 |
| **latency 추가** | ~1-3ms per hop | 없음 |

### 6.2 공격 시나리오별 비교

| 공격 시나리오 | mTLS | URR 현재 | 위험도 |
|--------------|------|----------|--------|
| 클러스터 외부에서 서비스 직접 호출 | 차단 | **차단** (ClusterIP) | 낮음 |
| 허가되지 않은 Pod에서 서비스 호출 | 차단 (인증서 없음) | **차단** (NetworkPolicy) | 낮음 |
| 허가된 Pod에서 잘못된 내부 API 호출 | 차단 (AuthorizationPolicy) | **차단** (토큰 검증) | 낮음 |
| 클러스터 내부 네트워크 스니핑 | **차단** (TLS) | 노출 (평문) | 중간 |
| INTERNAL_API_TOKEN 유출 | 해당 없음 | 모든 내부 API 접근 가능 | 중간 |
| 컨테이너 탈출 (container escape) | 제한적 방어 | 제한적 방어 | 높음 |

### 6.3 현실적 위험 평가

**클러스터 내부 스니핑 위험:**
- EKS 워커 노드는 AWS VPC 내부에 있고, 노드 간 통신은 VPC 네트워크를 통해 이루어진다
- VPC 내부 트래픽은 AWS 인프라에서 격리되어 있어 외부 스니핑이 사실상 불가능
- 위험은 **노드가 침해된 경우**에만 현실적 → 이 경우 mTLS도 완전한 방어 불가

**INTERNAL_API_TOKEN 유출 위험:**
- 토큰은 K8s Secret으로 관리 → Secret 접근 권한이 있는 사람만 열람 가능
- 모든 서비스가 같은 토큰 → 하나의 서비스 컨테이너 침해 시 다른 서비스 내부 API 접근 가능
- **완화 방안**: 서비스별 다른 토큰 사용 (현재 미적용)

---

## 7. AWS 배포 시 추가되는 TLS 구간

현재 Terraform 설정에서 데이터 레이어는 이미 TLS가 적용되어 있다.

### 7.1 이미 TLS가 적용된 구간

| 구간 | TLS 설정 | 출처 |
|------|---------|------|
| Client → CloudFront | TLS 1.3 (ACM 인증서) | `cloudfront/main.tf` |
| CloudFront → ALB | HTTPS origin | `cloudfront/main.tf:94` (`https-only`) |
| Pod → RDS | TLS (RDS 기본 강제) | `rds/main.tf:59` |
| Pod → ElastiCache | TLS | `elasticache/main.tf:113` (`transit_encryption_enabled = true`) |
| Pod → MSK | TLS | `msk/main.tf:163` (`client_broker = "TLS"`) |
| Spring Boot → Redis | SSL | `ticket-service/application.yml:123-124` (`ssl.enabled: true`, prod 프로필) |

### 7.2 TLS가 없는 구간

| 구간 | 현재 상태 | 위험도 | 완화 방안 |
|------|----------|--------|-----------|
| ALB → Gateway Pod | 평문 HTTP | 낮음 (VPC 내부) | ALB → HTTPS target group 전환 |
| Gateway → 내부 서비스 | 평문 HTTP | 낮음 (같은 노드/VPC) | Istio mTLS 또는 Spring TLS |
| 서비스 ↔ 서비스 (internal) | 평문 HTTP | 중간 | Istio mTLS 권장 |

---

## 8. 평가

### 8.1 현재 구조의 강점

1. **Default-Deny NetworkPolicy**: 모든 통신을 기본 차단 후 화이트리스트로 허용 — 최소 권한 원칙 적용 (`network-policies.yaml:1-9`)
2. **서비스별 세분화된 Ingress/Egress 규칙**: 8개 서비스 각각에 대해 허용된 호출자와 목적지를 명시 (총 17개 NetworkPolicy)
3. **Timing-safe 토큰 비교**: `MessageDigest.isEqual()` 사용으로 타이밍 공격 방지 (`InternalTokenValidator.java:28-31`)
4. **Prod Egress CIDR 제한**: AWS VPC 서브넷 단위로 외부 접근을 제한 (`network-policy-egress.yaml`)
5. **데이터 레이어 TLS 완비**: RDS, Redis, Kafka 모두 전송 중 암호화 적용
6. **운영 단순성**: Istio 없이도 실용적인 보안 수준 확보

### 8.2 미흡한 점

1. **Pod 간 평문 HTTP**: 클러스터 내부 서비스 간 통신이 암호화되지 않음
2. **단일 공유 토큰**: `INTERNAL_API_TOKEN` 하나로 모든 서비스 인증 → 토큰 유출 시 전체 내부 API 노출
3. **서비스 ID 부재**: 호출자가 "어떤 서비스"인지 토큰만으로 구분 불가 (gateway든 payment든 같은 토큰)
4. **ALB → Pod 구간 평문**: CloudFront→ALB는 HTTPS지만 ALB→Pod는 HTTP (VPC 내부이므로 위험도 낮음)

### 8.3 향후 보완 방안

| 방안 | 복잡도 | 효과 | 적합 시점 |
|------|--------|------|-----------|
| 서비스별 별도 `INTERNAL_API_TOKEN` | 낮음 | 토큰 유출 피해 범위 축소 | 즉시 적용 가능 |
| ALB Target Group HTTPS 전환 | 낮음 | ALB→Pod TLS 확보 | 즉시 적용 가능 |
| AWS App Mesh (Envoy 기반) | 중간 | AWS 네이티브 mTLS | 서비스 15개+ |
| Linkerd (경량 서비스 메시) | 중간 | 자동 mTLS, 낮은 오버헤드 | 서비스 15-30개 |
| Istio (풀 서비스 메시) | 높음 | mTLS + 관찰성 + 정책 관리 | 서비스 30개+ 또는 규제 요구 |
